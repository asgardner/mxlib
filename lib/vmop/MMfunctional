/** \file MMfunctional
  * \brief Functions for indexing over MMatrices and function objects to apply.
  * 
  * \author Jared R. Males (jaredmales@gmail.com)
  *
  */
  
#ifndef __mx_MMfunctional__
#define __mx_MMfunctional__

#include "MMtraits"

#define  neg_one  ( (size_t) -1) 

namespace mx
{

///Function object which just returns its argument.
/**
  * \param x is the number to return
  * \param y [optional] included for compatibility
  * 
  * \returns x \f$
  * 
  * \tparam T is the argument and return type
  * 
  */ 
template <class T> 
struct copy
{
   T operator() (const T& x) const {return x;}
   T operator() (const T& x, const T& y) const {return y;}
   typedef T first_argument_type;
   typedef T second_argument_type;
   typedef T result_type;
};

///Function object which finds the remainder of division of two numbers.
/**
  * \param x is the number to divide
  * \param y is the number to divide by
  * 
  * \return the remainder of \f$ x/y \f$
  * 
  * \tparam T is the argument and return type
  * 
  */ 
template <class T> 
struct fmodulo 
{
   T operator() (const T& x, const T& y) const {return std::fmod(x,y);}
   typedef T first_argument_type;
   typedef T second_argument_type;
   typedef T result_type;
};

///Function object which takes its first argument to the power of its second.
/**
  * \param x is the base
  * \param y is the exponent
  * 
  * \returns \f$ x^y \f$
  * 
  * \tparam T is the argument and return type
  * 
  */ 
template <class T> 
struct power
{
   T operator() (const T& x, const T& y) const {return std::pow(x,y);}
   typedef T first_argument_type;
   typedef T second_argument_type;
   typedef T result_type;
};

///Function object which finds the square of its argument.
/**
  * \param x is the value to find the square of.
  * \param y [optional] ignored, included for compatibility.
  * 
  * \returns \f$ x^2 \f$
  * 
  * \tparam T is the argument and return type
  */ 
template <class T> 
struct square
{
   T operator() (const T& x) const {return x * x;}
   T operator() (const T& x, const T& y) const {return x * x;}
   typedef T first_argument_type;
   typedef T second_argument_type;
   typedef T result_type;
};

///Function object which finds the square root of its argument.
/**
  * \param x is the value to find the square root of.
  * \param y [optional] ignored, included for compatibility.
  * 
  * \returns \f$ \sqrt{x} \f$
  * 
  * \tparam T is the argument and return type
  */ 
template <class T> 
struct sqrt
{
   T operator() (const T& x) const {return std::sqrt(x);}
   T operator() (const T& x, const T& y) const {return std::sqrt(x);}
   typedef T first_argument_type;
   typedef T second_argument_type;
   typedef T result_type;
};






///Function object which finds the inverse cosine of its argument.
/**
  * \param x is the value to find the inverse cosine of.
  * \param y [optional] ignored, included for compatibility.
  * 
  * \returns \f$ \acos{x} \f$
  * 
  * \tparam T is the argument and return type
  */ 
template <class T> 
struct acos
{
   T operator() (const T& x) const {return std::acos(x);}
   T operator() (const T& x, const T& y) const {return std::acos(x);}
   typedef T first_argument_type;
   typedef T second_argument_type;
   typedef T result_type;
};




///Function object which finds the natural exponential of its argument, e^x.
/**
  * \param x is the value to find the exponential of.
  * \param y [optional] ignored, included for compatibility.
  * 
  * \returns \f$ e^x \f$
  * 
  * \tparam T is the argument and return type
  */ 
template <class T> 
struct exp
{
   T operator() (const T& x) const {return std::exp(x);}
   T operator() (const T& x, const T& y) const {return std::exp(x);}
   typedef T first_argument_type;
   typedef T second_argument_type;
   typedef T result_type;
};

///Function object which finds the common exponential of its argument, 10^x.
/**
  * \param x is the value to take the base-10 exponenent of.
  * \param y [optional] ignored, included for compatibility.
  * 
  * \returns \f$ 10^x \f$
  * 
  * \tparam T is the argument and return type
  */ 
template <class T> 
struct exp10
{
   T operator() (const T& x) const {return std::pow<T>(10, x);}
   T operator() (const T& x, const T& y) const {return std::pow<T>(10, x);}
   typedef T first_argument_type;
   typedef T second_argument_type;
   typedef T result_type;
};

///Function object which finds the exponential of its argument with an arbitrary base.
/**
  * \param x is the value to take the base-X exponenent of.
  * \param b is the base of the exponent
  * 
  * \returns \f$ b^x \f$
  * 
  * \tparam T is the argument and return type
  */ 
template <class T> 
struct expX
{
   T operator() (const T& x, const T& b) const {return std::pow<T>(b, x);}
   typedef T first_argument_type;
   typedef T second_argument_type;
   typedef T result_type;
};

///Function object which finds the natural (base-e) logarithm of its argument.
/**
  * \param x is the value to find the logarithm of.
  * \param y [optional] ignored, included for compatibility.
  * 
  * \returns the base-e natrual logarithm of x
  * 
  * \tparam T is the argument and return type
  */ 
template <class T> 
struct log
{
   T operator() (const T& x) const {return std::log(x);}
   T operator() (const T& x, const T& y) const {return std::log(x);}
   typedef T first_argument_type;
   typedef T second_argument_type;
   typedef T result_type;
};

///Function object which finds the common (base-10) logarithm of its argument.
/**
  * \param x is the value to find the logarithm of.
  * \param y [optional] ignored, included for compatibility.
  * 
  * \returns the base-10 logarithm of x
  * 
  * \tparam T is the argument and return type
  */ 
template <class T> 
struct log10
{
   T operator() (const T& x) const {return std::log10(x);}
   T operator() (const T& x, const T& y) const {return std::log10(x);}
   typedef T first_argument_type;
   typedef T result_type;
};

///Function object which finds the absolute value of its argument.
/**
  * \param x is the value to find the absolute value of.
  * \param y [optional] ignored, included for compatibility.
  * 
  * \returns the absolute value of x
  * 
  * \tparam resT is the result type, not necessarily the same as the argument type
  * \tparam argT is the argument type
  */ 
template <class resT, class argT> 
struct abs
{
   resT operator() (const argT& x) const {return std::abs(x);}
   resT operator() (const argT& x, const argT& y) const {return std::abs(x);}
   typedef argT first_argument_type;
   typedef resT result_type;
};

/// Increment an index, which is an array of matrix coordinates.
/** This is called by various functions which loop over the matrix.  It is implemented separately
  * to allow easy specialization by dimension.
  *
  * \tparam _dim is the dimension of the index
  *
  * \param _index is an array of length \p _dim holding the coordinates
  * \param _length is an array of length \p _dim specifying the max coordinate+1 of each dimension
  *
  */
template<size_t _dim>
inline void mmatrix_index_increment(size_t * _index, const size_t *_length)
{
   //Increment highest dimension first and return if possible
   _index[_dim-1] += 1;
   
   if(_index[_dim-1] < _length[_dim-1]) return;

   //Time to go to next dimension(s) and increment.
   _index[_dim-1] = 0;
   
   if(_dim > 1) //This is necessary to prevent size_t wraparound.  It should optimize away . . .
   {
      size_t i = _dim-2;
      while(i != neg_one)
      //for(size_t i=_dim-2;i>=0;i--)
      {
         _index[i] += 1;
      
         if(_index[i] < _length[i]) return;

         _index[i] = 0;
         
         --i;
      }
   }
   _index[0] = _length[0]; //This delivers correct "one past the end" behavior
   return;
   
}

///Specialization of mmatrix_index_increment for _dim = 1
template<>
inline void mmatrix_index_increment<1>(size_t * _index, const size_t *_length)
{
   _index[0] += 1;
   
   return;
   
}

///Specialization of mmatrix_index_increment for _dim = 2
template<>
inline void mmatrix_index_increment<2>(size_t * _index, const size_t *_length)
{
   _index[1] += 1;
   
   if(_index[1] < _length[1]) return;

   _index[1] = 0;
   
   _index[0] += 1;
 
   return;
   
}

///Specialization of mmatrix_index_increment for _dim = 3
template<>
inline void mmatrix_index_increment<3>(size_t * _index, const size_t *_length)
{
   _index[2] += 1;
   
   if(_index[2] < _length[2]) return;
   
   _index[2] = 0;
   
   _index[1] += 1;
 
   if(_index[1] < _length[1]) return;
   
   _index[1] = 0;
   
   _index[0] += 1;
   
   return;
   
}

//We have a separate set of _inplace_ functions to allow calculating the address only once
//this is different from calling the non-inplace functions with input and output matrices equal
template<class mmatrixT, class fobjT>
inline void loop0_inplace_stride(mmatrixT & m, const fobjT & fobj)
{ 
   size_t index[mmatrixT::dimension] = {};
   
   typename mmatrixT::data_type * ptr = m.get_ptr(index);//Calculate address only once.
   
   *ptr = fobj(*ptr);
   
   mmatrix_index_increment<mmatrixT::dimension>(index, m.length());
   
   while(index[0] < m.length(0))
   {
      ptr = m.get_ptr(index);
   
      *ptr = fobj(*ptr);
   
      mmatrix_index_increment<mmatrixT::dimension>(index, m.length());
   }   
}   

template<class mmatrixT, class fobjT>
inline void loop0_inplace_direct(mmatrixT & m, const fobjT & fobj)
{ 
   size_t tot_length = m.total_length();
 
   for(size_t index=0; index < tot_length; index++)
   {
      m.set_direct(index, fobj(m.get_direct(index)));   
   }   
}   

template<class mmatrixT, class fobjT>
inline void loop0_inplace(mmatrixT & m, const fobjT & fobj)
{
   if(m.vector()) loop0_inplace_stride(m, fobj);
   else loop0_inplace_direct(m, fobj);
}




template<class mmatrixT_in, class mmatrixT_out, class fobjT>
inline void loop0_stride_both(mmatrixT_in & m_in, mmatrixT_out & m_out,  const fobjT & fobj)
{ 
   size_t index[mmatrixT_in::dimension] = {};
   
   m_out.set(index, fobj(m_in.get(index)));
   
   mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
   
   while(index[0] < m_in.length(0))
   {
      m_out.set(index, fobj(m_in.get(index)));
      
      mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
   }   
}   

template<class mmatrixT_in, class mmatrixT_out, class fobjT>
inline void loop0_stride_in(mmatrixT_in & m_in, mmatrixT_out & m_out,  const fobjT & fobj)
{ 
   size_t index[mmatrixT_in::dimension] = {};
   size_t direct = 0;
   
   m_out.set_direct(direct, fobj(m_in.get(index)));
   
   mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
   ++direct;
   
   while(index[0] < m_in.length(0))
   {
      m_out.set_direct(direct, fobj(m_in.get(index)));
      
      mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
      ++direct;
   }   
}   

template<class mmatrixT_in, class mmatrixT_out, class fobjT>
inline void loop0_stride_out(mmatrixT_in & m_in, mmatrixT_out & m_out,  const fobjT & fobj)
{ 
   size_t index[mmatrixT_in::dimension] = {};
   size_t direct = 0;
   
   m_out.set(index, fobj(m_in.get_direct(direct)));
   
   mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
   ++direct;
   
   while(index[0] < m_in.length(0))
   {
      m_out.set(index, fobj(m_in.get_direct(direct)));
      
      mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
      ++direct;
   }   
}   

template<class mmatrixT_in, class mmatrixT_out, class fobjT>
inline void loop0_direct(mmatrixT_in & m_in, mmatrixT_out & m_out,  const fobjT & fobj)
{ 
   size_t tot_length = m_in.total_length();
 
   for(size_t index=0; index < tot_length; index++)
   {
      m_out.set_direct(index, fobj(m_in.get_direct(index)));   
   }   
}   


template<class mmatrixT_in, class mmatrixT_out, class fobjT>
inline void loop0(mmatrixT_in & m_in, mmatrixT_out & m_out,  const fobjT & fobj)
{
   if(m_in.vector() == m_out.vector())
   {
      if(m_in.vector() == false) 
      {
         return loop0_direct(m_in, m_out,  fobj);
      }
      else
      {
         return loop0_stride_both(m_in, m_out,  fobj);
      }
   }
   else
   {
      if(m_in.vector() == true)
      {
         return loop0_stride_in(m_in, m_out,  fobj);
      }
      else
      {
         return loop0_stride_out(m_in, m_out,  fobj);
      }
   }
}

template<class mmatrixT, class fobjT, class argT>
inline void loop1_inplace_stride(mmatrixT & m, const fobjT & fobj, const argT & arg)
{ 
   size_t index[mmatrixT::dimension] = {};
   
   typename mmatrixT::data_type * ptr = m.get_ptr(index);//Calculate address only once.
   
   *ptr = fobj(*ptr , arg);
   
   mmatrix_index_increment<mmatrixT::dimension>(index, m.length());
   
   while(index[0] < m.length(0))
   {
      ptr = m.get_ptr(index);
   
      *ptr = fobj(*ptr , arg);
   
      mmatrix_index_increment<mmatrixT::dimension>(index, m.length());
   }   
}   

template<class mmatrixT, class fobjT, class argT>
inline void loop1_inplace_direct(mmatrixT & m, const fobjT & fobj, const argT & arg)
{ 
      
   size_t tot_length = m.total_length();
 
   for(size_t index=0; index < tot_length; index++)
   {
      m.set_direct(index, fobj(m.get_direct(index), arg));   
   }   
}   

template<class mmatrixT, class fobjT, class argT>
inline void loop1_inplace(mmatrixT & m, const fobjT & fobj, const argT & arg)
{
   if(m.vector()) loop1_inplace_stride(m, fobj, arg);
   else loop1_inplace_direct(m, fobj, arg);
}








template<class mmatrixT_in, class mmatrixT_out, class fobjT, class argT>
inline void loop1_stride_both( mmatrixT_in & m_in, 
                               mmatrixT_out & m_out, 
                               const fobjT & fobj, 
                               const argT & arg)
{ 
   size_t index[mmatrixT_in::dimension] = {};
   
   m_out.set(index,  fobj(m_in.get(index) , arg));
   
   mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
   
   while(index[0] < m_in.length(0))
   {
      m_out.set(index,  fobj(m_in.get(index) , arg));
      
      mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
   }   
}   

template<class mmatrixT_in, class mmatrixT_out, class fobjT, class argT>
inline void loop1_stride_in( mmatrixT_in & m_in, 
                             mmatrixT_out & m_out, 
                             const fobjT & fobj, 
                             const argT & arg)
{ 
   size_t index[mmatrixT_in::dimension] = {};
   size_t direct = 0;
   
   m_out.set_direct(direct,  fobj(m_in.get(index) , arg));
   
   mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
   ++direct;
   
   while(index[0] < m_in.length(0))
   {
      m_out.set_direct(direct,  fobj(m_in.get(index) , arg));
      
      mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
      ++direct;
   }   
}   

template<class mmatrixT_in, class mmatrixT_out, class fobjT, class argT>
inline void loop1_stride_out( mmatrixT_in & m_in, 
                              mmatrixT_out & m_out, 
                              const fobjT & fobj, 
                              const argT & arg)
{ 
   size_t index[mmatrixT_in::dimension] = {};
   size_t direct = 0;
   
   m_out.set(index,  fobj(m_in.get_direct(direct) , arg));
   
   mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
   ++direct;
   
   while(index[0] < m_in.length(0))
   {
      m_out.set(index,  fobj(m_in.get_direct(direct) , arg));
      
      mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
      ++direct;
   }   
}   

template<class mmatrixT_in, class mmatrixT_out, class fobjT, class argT>
inline void loop1_direct( mmatrixT_in & m_in, 
                          mmatrixT_out & m_out, 
                          const fobjT & fobj, 
                          const argT & arg)
{ 
   size_t tot_length = m_in.total_length();
 
   for(size_t index=0; index < tot_length; index++)
   {
      m_out.set_direct(index, fobj(m_in.get_direct(index), arg));   
   }   
}   

template<class mmatrixT_in, class mmatrixT_out, class fobjT, class argT>
inline void loop1( mmatrixT_in & m_in, 
                   mmatrixT_out & m_out,  
                   const fobjT & fobj, 
                   const argT & arg)
{
   if(m_in.vector() == m_out.vector())
   {
      if(m_in.vector() == false)
      {
         loop1_direct(m_in, m_out, fobj, arg);
      }
      else
      {
         loop1_stride_both(m_in, m_out, fobj, arg);
      }
   }
   else
   {
      if(m_in.vector() == true)
      {
         loop1_stride_in(m_in, m_out, fobj, arg);
      }
      else
      {
         loop1_stride_out(m_in, m_out, fobj, arg);
      }
   }
}





//----------------------------------//
// loop 2
//----------------------------------//

///Loop over matrices using strides for both, applying a function object to the elements.
template<class mmatrixT, class fobjT, class mmatrix_argT>
inline void loop2_inplace_stride_both( mmatrixT & m, 
                                       const fobjT & fobj, 
                                       const mmatrix_argT & arg )
{ 
   size_t index[mmatrixT::dimension] = {};
   
   typename mmatrixT::data_type * ptr = m.get_ptr(index);//Calculate address only once.
   
   *ptr = fobj(*ptr , arg.get(index));
   
   mmatrix_index_increment<mmatrixT::dimension>(index, m.length());
   
   while(index[0] < m.length(0))
   {
      ptr = m.get_ptr(index);
   
      *ptr = fobj(*ptr , arg.get(index));
   
      mmatrix_index_increment<mmatrixT::dimension>(index, m.length());
   }   
}   

///Loop over matrices using stride for the caller, direct access for the arg, and apply a function object to the elements.
template<class mmatrixT, class fobjT, class mmatrix_argT>
inline void loop2_inplace_stride_caller( mmatrixT & m, 
                                         const fobjT & fobj, 
                                         const mmatrix_argT & arg )
{ 
   size_t direct = 0;
   size_t index[mmatrixT::dimension] = {};
   
   typename mmatrixT::data_type * ptr = m.get_ptr(index);//Calculate address only once.
   
   *ptr = fobj(*ptr , arg.get_direct(direct));
   
   mmatrix_index_increment<mmatrixT::dimension>(index, m.length());
   direct++;
   
   while(index[0] < m.length(0))
   {
      ptr = m.get_ptr(index);
   
      *ptr = fobj(*ptr , arg.get_direct(direct));
   
      mmatrix_index_increment<mmatrixT::dimension>(index, m.length());
      direct++;
   }   
}   

///Loop over matrices using stride for the arg, direct access for the caller, and apply a function object to the elements.
template<class mmatrixT, class fobjT, class mmatrix_argT>
inline void loop2_inplace_stride_arg( mmatrixT & m, 
                                         const fobjT & fobj, 
                                         const mmatrix_argT & arg )
{ 
   size_t direct = 0;
   size_t index[mmatrixT::dimension] = {};
   
   typename mmatrixT::data_type * ptr = m.get_ptr_direct(direct);//Calculate address only once.
   
   *ptr = fobj(*ptr , arg.get(index));
   
   mmatrix_index_increment<mmatrixT::dimension>(index, m.length());
   direct++;
   
   while(index[0] < m.length(0))
   {
      ptr = m.get_ptr_direct(direct);
   
      *ptr = fobj(*ptr , arg.get(index));
   
      mmatrix_index_increment<mmatrixT::dimension>(index, m.length());
      direct++;
   }   
}   

///Loop over matrices using direct access for both, applying a function object to the elements.
template<class mmatrixT, class fobjT, class mmatrix_argT>
inline void loop2_inplace_direct( mmatrixT & m, 
                                  const fobjT & fobj, 
                                  const mmatrix_argT & arg )
{ 

   size_t tot_length = m.total_length();
 
   for(size_t index=0; index < tot_length; index++)
   {
      m.set_direct(index, fobj(m.get_direct(index), arg.get_direct(index)));   
   }
}

///Loop over matrices, applying a function object to the elements.
template<class mmatrixT, class fobjT, class mmatrix_argT>
inline void loop2_inplace( mmatrixT & m, 
                           const fobjT & fobj, 
                           const mmatrix_argT & arg )
{
   if(m.vector() == arg.vector())
   {
      if(m.vector() == false) 
      {
         return loop2_inplace_direct(m, fobj, arg);
      }
      else
      {
         return loop2_inplace_stride_both(m, fobj, arg);
      }
   }
   else
   {
      if(m.vector() == false) 
      {
         return loop2_inplace_stride_arg(m, fobj, arg);
      }
      else
      {
         return loop2_inplace_stride_caller(m, fobj, arg);
      }
   }
}




template<class mmatrixT_in, class mmatrixT_out, class fobjT, class mmatrix_argT>
inline void loop2_stride_all( mmatrixT_in & m_in,
                              mmatrixT_out & m_out, 
                              const fobjT & fobj, 
                              const mmatrix_argT & arg )
{ 
   
   size_t index[mmatrixT_in::dimension] = {};
   
   m_out.set(index, fobj(m_in.get(index), arg.get(index)));
   
   mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
   
   while(index[0] < m_in.length(0))
   {
      m_out.set(index, fobj(m_in.get(index), arg.get(index)));
   
      mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
   }   
}   


template<class mmatrixT_in, class mmatrixT_out, class fobjT, class mmatrix_argT>
inline void loop2_stride_in_and_out( mmatrixT_in & m_in,
                                             mmatrixT_out & m_out, 
                                             const fobjT & fobj, 
                                             const mmatrix_argT & arg )
{ 
   size_t direct = 0;
   
   size_t index[mmatrixT_in::dimension] = {};
   
   m_out.set(index, fobj(m_in.get(index), arg.get_direct(direct)));
   
   mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
   direct++;
   
   while(index[0] < m_in.length(0))
   {
      m_out.set(index, fobj(m_in.get(index), arg.get_direct(direct)));
   
      mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
      direct++;
   }   
}   

template<class mmatrixT_in, class mmatrixT_out, class fobjT, class mmatrix_argT>
inline void loop2_stride_in_and_arg( mmatrixT_in & m_in,
                                             mmatrixT_out & m_out, 
                                             const fobjT & fobj, 
                                             const mmatrix_argT & arg )
{ 
   size_t direct = 0;
   
   size_t index[mmatrixT_in::dimension] = {};
   
   m_out.set_direct(direct, fobj(m_in.get(index), arg.get(index)));
   
   mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
   direct++;
   
   while(index[0] < m_in.length(0))
   {
      m_out.set_direct(direct, fobj(m_in.get(index), arg.get(index)));
   
      mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
      direct++;
   }   
}   

template<class mmatrixT_in, class mmatrixT_out, class fobjT, class mmatrix_argT>
inline void loop2_stride_out_and_arg( mmatrixT_in & m_in,
                                              mmatrixT_out & m_out, 
                                              const fobjT & fobj, 
                                              const mmatrix_argT & arg )
{ 
   size_t direct = 0;
   
   size_t index[mmatrixT_in::dimension] = {};
   
   m_out.set(index, fobj(m_in.get_direct(direct), arg.get(index)));
   
   mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
   direct++;
   
   while(index[0] < m_in.length(0))
   {
      m_out.set(index, fobj(m_in.get_direct(direct), arg.get(index)));
   
      mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
      direct++;
   }   
}   

template<class mmatrixT_in, class mmatrixT_out, class fobjT, class mmatrix_argT>
inline void loop2_stride_argonly( mmatrixT_in & m_in,
                                  mmatrixT_out & m_out, 
                                  const fobjT & fobj, 
                                  const mmatrix_argT & arg )
{ 
   size_t direct = 0;
   
   size_t index[mmatrixT_in::dimension] = {};
   
   m_out.set_direct(direct, fobj(m_in.get_direct(direct), arg.get(index)));
   
   mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
   direct++;
   
   while(index[0] < m_in.length(0))
   {
      m_out.set_direct(direct, fobj(m_in.get_direct(direct), arg.get(index)));
   
      mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
      direct++;
   }   
}   

template<class mmatrixT_in, class mmatrixT_out, class fobjT, class mmatrix_argT>
inline void loop2_stride_inonly( mmatrixT_in & m_in,
                                 mmatrixT_out & m_out, 
                                 const fobjT & fobj, 
                                 const mmatrix_argT & arg )
{ 
   size_t direct = 0;
   
   size_t index[mmatrixT_in::dimension] = {};
   
   m_out.set_direct(direct, fobj(m_in.get(index), arg.get_direct(direct)));
   
   mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
   direct++;
   
   while(index[0] < m_in.length(0))
   {
      m_out.set_direct(direct, fobj(m_in.get(index), arg.get_direct(direct)));
   
      mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
      direct++;
   }   
}

template<class mmatrixT_in, class mmatrixT_out, class fobjT, class mmatrix_argT>
inline void loop2_stride_outonly( mmatrixT_in & m_in,
                                  mmatrixT_out & m_out, 
                                  const fobjT & fobj, 
                                  const mmatrix_argT & arg )
{ 
   size_t direct = 0;
   
   size_t index[mmatrixT_in::dimension] = {};
   
   m_out.set(index, fobj(m_in.get_direct(direct), arg.get_direct(direct)));
   
   mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
   direct++;
   
   while(index[0] < m_in.length(0))
   {
      m_out.set(index, fobj(m_in.get_direct(direct), arg.get_direct(direct)));
   
      mmatrix_index_increment<mmatrixT_in::dimension>(index, m_in.length());
      direct++;
   }   
}

template<class mmatrixT_in, class mmatrixT_out, class fobjT, class mmatrix_argT>
inline void loop2_direct( mmatrixT_in & m_in,
                          mmatrixT_out & m_out,
                          const fobjT & fobj, 
                          const mmatrix_argT & arg )
{ 
   size_t tot_length = m_in.total_length();
 
   for(size_t index=0; index < tot_length; index++)
   {
      m_out.set_direct(index, fobj(m_in.get_direct(index), arg.get_direct(index)));   
   }
}

///Loop over matrices, applying a function object to the elements.
template<class mmatrixT_in, class mmatrixT_out, class fobjT, class mmatrix_argT>
inline void loop2( mmatrixT_in        & m_in,
                   mmatrixT_out       & m_out,
                   const fobjT        & fobj, 
                   const mmatrix_argT & arg )
{
   if(m_in.vector() == m_out.vector())
   {   
      if(m_in.vector() == arg.vector())
      {
         if(m_in.vector() == false)
         {  //none are vector
            loop2_direct(m_in, m_out, fobj, arg);
         }
         else
         { //all are vector
            loop2_stride_all(m_in, m_out, fobj, arg);
         }
      }
      else
      {
         if(m_in.vector() == false)
         { //only arg is vector
            loop2_stride_argonly(m_in, m_out, fobj, arg);
         }
         else
         { //only arg is NOT vector
            loop2_stride_in_and_out(m_in, m_out, fobj, arg);
         }
      }
   }
   else
   {
      if(m_in.vector() == arg.vector())
      {
         if(m_in.vector() == false)
         { //only out is vector
            loop2_stride_outonly(m_in, m_out, fobj, arg);
         }
         else
         { //only out is NOT vector
            loop2_stride_in_and_arg(m_in, m_out, fobj, arg);
         }
      }
      else
      {
         if(m_in.vector() == false)
         { //only in is NOT vector
            loop2_stride_out_and_arg(m_in, m_out, fobj, arg);
         }
         else
         {
            //only in is vector
            loop2_stride_inonly(m_in, m_out, fobj, arg);
         }
      }
   }
}






//--------------------------------------------------------------//
//  In-place addition
//--------------------------------------------------------------//

///Template function object to do in-place application of a functor.  Default version for non-MMatrix types.
template <class mmatrixT_in, class fobjT, class argT, bool enable = mx::is_mmatrix<argT>::value>
struct do_fobj_inplace
{
   void operator()(mmatrixT_in & m_in, const fobjT & fobj, const argT & arg)
   {
      loop1_inplace(m_in, fobj, arg);
   }
};

///Specialization of the function object to do in-place application of a functor for MMatrix types.
template<class mmatrixT_in, class fobjT, class argT>
struct do_fobj_inplace<mmatrixT_in, fobjT, argT, true>
{
   void operator()(mmatrixT_in & m_in, const fobjT & fobj, const argT & arg)
   {
      loop2_inplace(m_in, fobj, arg);
   }
};


///Template function object to do addition.  Default version for non-MMatrix types.
template <class mmatrixT_in, class fobjT, class argT, bool enable = mx::is_mmatrix<argT>::value>
struct do_fobj
{
   void operator()(mmatrixT_in & m_in, mmatrixT_in & m_out, const fobjT & fobj, const argT & arg)
   {
      loop1(m_in, m_out, fobj, arg);
   }
};

///Specialization of the function object to do addition for MMatrix types.
template<class mmatrixT_in, class fobjT, class argT>
struct do_fobj<mmatrixT_in, fobjT, argT, true>
{
   void operator()(mmatrixT_in & m_in, mmatrixT_in & m_out, const fobjT & fobj, const argT & arg)
   {
      loop2(m_in, m_out, fobj, arg);
   }
};


///Template function object to apply a function object with an r-value argument.  Default version for non-MMatrix types.
template <class mmatrixT_in, class fobjT, class argT, bool enable = mx::is_mmatrix<argT>::value>
struct do_fobj_move
{
   void operator()(mmatrixT_in & m_in, mmatrixT_in & m_out, const fobjT & fobj, const argT & arg)
   {
      m_out.allocate(m_in.length());
      loop1(m_in, m_out, fobj, arg);
   }
};

///Template function object to apply a function object with an r-value argument, specialization for MMatrix types.
template <class mmatrixT_in, class fobjT, class argT>
struct do_fobj_move<mmatrixT_in, fobjT, argT, true>
{
   void operator()(mmatrixT_in & m_in, mmatrixT_in & m_out, const fobjT & fobj, const argT && arg)
   {
      if(arg.owner())
      {
         m_out.move( (mmatrixT_in &&) arg);
         loop2_inplace(m_out, fobj, m_in);
      }
      else
      {
         m_out.resize(m_in.length());
         loop2(m_in, m_out, fobj, arg);
      }
   }
};



}//namespace mx

#endif // __mx_MMfunctional__

