
#ifndef __mx_MMatrixView__
#define __mx_MMatrixView__

#include <iostream>
#include <cstdarg>
#include <cmath>
#include <complex>


#include "MMatrixBase"



namespace mx
{


///The Base Matrix View Class.
/** \ingroup mmatrix
  */
template<class dataT, size_t _dim, class absT=dataT> 
class MMatrixView : public MMatrixBase<dataT, _dim, absT>
{

public:
      
   /** @name Construction and Destruction
     */
   //@{
         
   ///Default constructor. Initializes the members but does not allocate storage.
   MMatrixView();

   ///Construct and initialize with the size of each dimension specified in an array of length 1.
   /** 
     * \param sizes is an array of length \p dim specifying the size of each dimension
     */
   explicit MMatrixView(const size_t *sizes);

   ///Construct from a c _data array.
   /** 
     * \param arr the c _data array
     * \param sizes holds the sizes of the array.
     */
   MMatrixView(dataT * arr, const size_t * sizes);
      
   ///Construct from a c _data array.
   /** 
     * \param arr the c _data array
     * \param sizes holds the sizes of the array.
     * \param offsets holds the sizes of the array.
     * \param strides holds the sizes of the array.
     */
   MMatrixView( dataT * arr, 
                    const size_t * sizes, 
                    const size_t * start, 
                    const size_t * stride, 
                    const size_t * end );
      
   ///Copy constructor, this is always a shallow copy.
   /**
     * \param m is the matrix to copy
     */
   explicit MMatrixView(const MMatrixBase<dataT, _dim, absT> & m);

   ///Move constructor.
   /**
     * \param m is an r-value reference to a matrix to copy.
     */
   explicit MMatrixView(const MMatrixBase<dataT, _dim, absT> && m);

   ///Destructor.  If owned, the _data storage is freed.
   virtual ~MMatrixView();

   //@}

   protected:
   
   ///Resizes the storage array, based on the (already set) this->_size[_dim] array.
   virtual void resize();
   
   ///Free the storage array, if owned.
   virtual void free();
   
   /** @name Allocation
     */
   //@{
   
   virtual void resize( const size_t * sizes, 
                        const size_t * start, 
                        const size_t * stride,
                        const size_t * end );
   
   virtual void resize( const size_t * sizes );
   
   ///Attach to a c _data array.
   /** First deals with existing storage array, if any.
     * Does not copy, rather just takes repoints, and does not take _ownership.
     * This means you are still responsible for the memory pointed to by arr.
     *
     * \param arr the c data array
     * \param sizes an array of length _dim specifying the sizes.
     */
   virtual void set_array( dataT * arr, 
                           const size_t * sizes );
                           
   ///Attach to a c data array.
   /** 
     * Does not copy, rather just takes repoints, and does not take _ownership.
     * This means you are still responsible for the memory pointed to by arr.
     *
     * \param arr the c _data array
     * \param sizes an array of length _dim specifying the sizes.
     * \param start
     * \param stride
     * \param end
     */
   virtual void set_array( dataT * arr, 
                           const size_t * sizes,
                           const size_t * start,
                           const size_t * stride,
                           const size_t * end );
                           
   //@}
      
   /** @name Assignment
     */  
   //@{
  
   ///Assignment operator
   /** This must be redefined for proper template resolution.
     *
     * \param m the matrix to assign from
     *
     * \returns a reference to *this
     */
   MMatrixBase<dataT, _dim, absT> & operator=(MMatrixBase<dataT, _dim, absT> & m);
   
   ///r-value assignment operator
   /** This must be redefined for proper template resolution.
     *
     * \param m the matrix to assign from
     *
     * \returns a reference to *this
     */
   MMatrixBase<dataT, _dim, absT> & operator=(MMatrixBase<dataT, _dim, absT> && m);  
   
   
   //@}
  
protected:

   
   ///Get the raw index given a set of coordinates.
   /** This is overriden from MMatrixBase, here it takes stride into account.
     * 
     * \param d is an array of length 1 which specifies the index along each dimension
     * \returns the linear index into the _data array.
     */
   virtual size_t idx(const size_t * d) const;

public:
      


};


template<class dataT, size_t _dim, class absT> 
MMatrixView<dataT, _dim, absT>::MMatrixView() : MMatrixBase<dataT, _dim, absT>()
{  
}

template<typename dataT, size_t _dim, typename absT>
MMatrixView<dataT, _dim, absT>::MMatrixView(const size_t * sizes) : MMatrixBase<dataT, _dim, absT>(sizes)
{
}


template<class dataT, size_t _dim, class absT> 
MMatrixView<dataT, _dim, absT>::MMatrixView(const MMatrixBase<dataT, _dim, absT> & m) : MMatrixBase<dataT, _dim, absT>(m, false)
{
}

template<class dataT, size_t _dim, class absT> 
MMatrixView<dataT, _dim, absT>::MMatrixView(const MMatrixBase<dataT, _dim, absT> && m) : MMatrixBase<dataT, _dim, absT>(m)
{
}

template<class dataT, size_t _dim, class absT> 
MMatrixView<dataT, _dim, absT>::MMatrixView(dataT * arr, const size_t *sizes)
{
   this->initialize();
   
   set_array(arr, sizes, 0, 0, 0);
}

template<class dataT, size_t _dim, class absT> 
MMatrixView<dataT, _dim, absT>::MMatrixView( dataT * arr, 
                                                     const size_t * sizes, 
                                                     const size_t * start, 
                                                     const size_t * stride,
                                                     const size_t * end )
{
   this->initialize();
   
   set_array(arr, sizes, start, stride, end);
}

template<class dataT, size_t _dim, class absT> 
MMatrixView<dataT, _dim, absT>::~MMatrixView()  
{
}

template<class dataT, size_t _dim,  class absT> 
void MMatrixView<dataT, _dim, absT>::resize()
{

   //First set [0] and initialize the accumulators
   this->_tot_size = this->_size[0];

   this->_tot_length = this->_length[0];
   
   this->_tda[0] = this->_size[0] - this->_length[0]*this->_stride[0];
   
   this->_size_prod[0] = 1;
   
   //Now do the remaining dimensions
   for(size_t i=1;i<_dim;i++)
   {  
      this->_tot_size *= this->_size[i];
      
      this->_tot_length *= this->_length[i];
      
      this->_tda[i] = this->_size[i] - this->_length[i]*this->_stride[i];
          
      this->_size_prod[i] = 1;
   }

   //Calculate size products
   for(size_t i=0; i < _dim; i++)
   {  
      for(size_t j=i+1; j<_dim;j++)
      {
         this->_size_prod[i] *= this->_size[j];
      }
   }

   //Just to be sure, always set this here.
   this->_owner = false;

}//void resize()

template<class dataT, size_t _dim,  class absT> 
void MMatrixView<dataT, _dim, absT>::free()
{
   return;
   
}//void free()

template<class dataT, size_t _dim, class absT> 
void MMatrixView<dataT, _dim, absT>::resize(const size_t * sizes)
{
   resize(sizes, 0, 0, 0);
}

template<class dataT, size_t _dim, class absT> 
void MMatrixView<dataT, _dim, absT>::resize( const size_t * sizes, 
                                                 const size_t * start, 
                                                 const size_t * stride,
                                                 const size_t * end )
{

   this->_strided = false;

   for(size_t i=0; i< _dim; i++)
   {
      this->_size[i] = sizes[i];
      
      if(start == 0) this->_offset[i] = 0;
      else this->_offset[i] = start[i];

      if(stride == 0) 
      {
         this->_stride[i] = 1;      
      }
      else 
      {
         this->_stride[i] = stride[i];
         if(stride[i] > 1) this->_strided = true;
      }
      
      ///\todo the cast to double when calculating _length might be a problem
      //it is probably slow, and may not be able to represent all bits in a size_t
      if(end == 0) this->_length[i] = ceil( (double)(this->_size[i] - this->_offset[i]) / this->_stride[i]);
      else this->_length[i] = ceil( (double)(end[i] - this->_offset[i]) / this->_stride[i]);
   }
   
   resize();
}//resize(const size_t *, const size_t *, const size_t *, const size_t *)

template<class dataT, size_t _dim, class absT>
void MMatrixView<dataT, _dim, absT>::set_array(dataT * arr, const size_t * sizes)
{
   set_array(arr, sizes, 0, 0, 0);
}

template<class dataT, size_t _dim, class absT>
void MMatrixView<dataT, _dim, absT>::set_array( dataT * arr, 
                                                const size_t * sizes, 
                                                const size_t * start, 
                                                const size_t * stride,
                                                const size_t * end )
{
   resize(sizes, start, stride, end); 
   
   this->_data = arr;
}

template<class dataT, size_t _dim, class absT> 
MMatrixBase<dataT, _dim, absT> & MMatrixView<dataT, _dim, absT>::operator=(MMatrixBase<dataT, _dim, absT> & m)
{ 
   return MMatrixBase<dataT, _dim, absT>::operator=(m); 
}

template<class dataT, size_t _dim, class absT> 
MMatrixBase<dataT, _dim, absT> & MMatrixView<dataT, _dim, absT>::operator=(MMatrixBase<dataT, _dim, absT> && m)
{ 
   return MMatrixBase<dataT, _dim, absT>::operator=((MMatrixBase<dataT, _dim, absT> &&) m); 
}
     


template<class dataT, size_t _dim, class absT> 
inline size_t MMatrixView<dataT, _dim, absT>::idx(const size_t * d) const
{
   //Since _dim is set at compile time, this should be easy to optimize 
   if(_dim == 1)
   {
      return this->_offset[0] + d[0]*this->_stride[0];
   }
   if(_dim == 2)
   {
      return (this->_offset[0]+ d[0]*this->_stride[0])*this->_size[1] +   this->_offset[1] + d[1]*this->_stride[1];
      
   }
   
   size_t _idx = 0;
   
   for(size_t i=0;i<_dim-1;i++) _idx += d[i]*this->_stride[i]*(this->_length[i]+this->_tda[i]);
   _idx += d[_dim-1]*this->_stride[_dim-1];
   
   return _idx;
}


//@}


}; //mx

#endif //__MMatrixView__



      
      