/** \file MMatrix1
  * \brief Declares and defines the 1-D Vector specialization of MMatrix
  *
  * \author Jared R. Males (jaredmales@gmail.com)
  *
  */
  
#ifndef __mx_MMatrix1__
#define __mx_MMatrix1__

#include "MMatrixBase"
#include "MMatrixView1"
#include "MMatrixVectorMathTemp"


namespace mx
{

   
template<typename dataT, size_t _dim, typename absT = dataT> class MMatrix;

/// The Vector Class: Partial specialization of the MMatrix template class, for 1 dimension.
/** \ingroup vmop
  * 
  * See the \ref mmatrix1_typedefs where typedefs are provided for the fundamental arithmetic types, 
  * e.g. mx::Vectord is a vector of doubles. 
  *
  * \tparam dataT is the data type being stored
  * \tparam absT is the type of the absolute value of dataT (default is absT = dataT)
  */
template<typename dataT, typename absT> 
class MMatrix<dataT, 1, absT> : public MMatrixBase<dataT, 1, absT, accessor_vector<1> >
{

public:
      
   /** @name Construction and Destruction
     * The standard MMatrixBase constructors are provided in addition to those documented here.
     */
   //@{
   
   /** \cond */
   //These are documented in MMatrixBase
   
   ///Default constructor. Initializes the members but does not allocate storage.
   MMatrix();

   ///Construct and allocate the _data array with the size of each dimension specified in an array of length 1.
   /** 
     * \param sizes is an array of length 1 specifying the size of each dimension
     */
   explicit MMatrix( size_t *sizes );

   ///Construct and allocate the _data array with the size of each dimension specified in an array of length 1. (const version)
   /** 
     * \param sizes is an array of length 1 specifying the size of each dimension
     */
   explicit MMatrix( const size_t *sizes );
   
   /** \endcond */
   
   ///Construct and allocate the data array with the specified size.
   /** 
     * \param size0  is the desired size.
     */  
   explicit MMatrix( const size_t size0 );
   
   /** \cond */
   
   ///Construct and allocate the data array with the specified size. (const version)
   /** 
     * \param size0  is the desired size.
     */  
   explicit MMatrix( const int size0 );
      
   /** \endcond */
   
   ///Construction from initializer list.
   /** Example:
     * \code
     * MMatrix<double, 1> m ({0.2, 0.5, 0.7, 0.8});
     * \endcode
     *
     * \param init is the initializer list
     */
   MMatrix( std::initializer_list<dataT> init );
   
   ///Generic MMatrixType Copy constructor.
   /**
     * \param m is the matrix to copy
     * 
     */
   template<class mmatrixT>
   MMatrix( const mmatrixT & m );
   
   /** \cond */
   
   /// Move constructor.
   /**  A shallow copy (re-point) is performed, and then ownership is taken of the storage array.
     *
     * \param m is an r-value reference to a matrix to copy.
     */
   template<class mmatrixT>
   MMatrix( mmatrixT && m );
   
   ///Destructor.  If owned, the _data storage is freed.
   ~MMatrix();

   /** \endcond */
   
   //@}

   /** @name Re-sizing 
     */
   //@{
         
   ///Resize the storage array
   /** If size does not change, and the block is already owned, this does nothing.
     *
     * \param size0 is the new size of the matrix
     */
   void allocate( const size_t size0 );
   
   /** \cond */
   
   /// Resize the storage array
   /** If total size does not change, and the block is already owned, this does nothing.
     * This is here to manage template base class lookup while keep virtual-ness, so it 
     * just calls MMatrixBase::allocate(size_t *).
     *
     * \param sizes is an array of length 1
     */
   void allocate( const size_t * sizes );
   
   /** \endcond */
   
   //@}
      
   /** @name Assignment
     */  
   //@{
  
   /** \cond */
   
   MMatrix & operator=(const MMatrix & m );
   MMatrix & operator=(MMatrix && m );
   
   /// Assignment operator
   /** 
     *
     * \param m the matrix to assign from
     *
     * \returns a reference to *this
     */
   template<class argT>
   MMatrix & operator=(const argT & m );
   
   
   
   /// r-value assignment operator
   /**  
     *
     * \param m the matrix to assign from
     *
     * \returns a reference to *this
     */
   template<class argT>
   MMatrix & operator=( argT && m );   
   
   /** \endcond */
  
   ///Initializer list assignment
   /**
     * \param init is an initalizer list of dataTs.
     *
     * \returns a reference to *this.
     */
   MMatrix<dataT, 1, absT> & assign_ilist(std::initializer_list<dataT> & init);
   
   ///Initializer list assignment operator
   /** Assign from an initializer list. Example:
     * \code
     * MMatrix<double, 1> vect  = {0.2, 0.5, 0.7, 0.8};
     * \endcode
     * 
     * This calls assign_ilist, where the work is done.
     * 
     * \param init is an initializer list of dataTs.
     *
     * \returns a reference to *this.
     */
   MMatrix<dataT, 1, absT> & operator=(std::initializer_list<dataT> init);
   
   //@}

   

   /** @name Element Access Operator
     */
   //@{
  
   
   /// Get a single element of the vector.
   /** This returns a single element, either as a reference or a const instance.
     *
     * \param d is the element index.  Can also be mx::BEG or mx::LAST.
     *
     * \returns type dataT
     */
   dataT & operator()( const size_t d );
   
   /** \cond */
   
   //Additional overloads
   dataT operator()( const size_t d ) const;   
   
   dataT & operator()( const MMatrixBound_BEG b );
   
   dataT operator()( const MMatrixBound_BEG b ) const;

   dataT & operator()( MMatrixBound_LAST l );
   
   dataT operator()( MMatrixBound_LAST l ) const;
   
   /** \endcond */
   
   //@}
   
   /** @name Views
     * The View operator returns a subrow of the vector.
     */
   //@{

   /** \cond */
   
   /// Get a view (subrow) of the vector
   /** This method is called by the view operators.  
     * 
     * \param start is the first element.
     * \param stride is the stepsize.
     * \param end is one past the last desired element.
     *
     * \returns an MMatrixView of the vector
     */
   MMatrixView<dataT, 1, absT, accessor_stride<1> > get_view( const size_t start, 
                                                              const size_t stride, 
                                                              const size_t end );
   
   MMatrixView<dataT, 1, absT, accessor_vector<1> > get_view( const size_t start,  
                                                              const size_t end );
   
   /** \endcond */
   
   /// Get a view (subrow) of the vector.
   /** This returns a view of the vector from element \p start to element \p end - 1, in steps
     * of size \p stride
     *
     * \param start is the first element, can also be mx::BEG to get the first element (same as 0)
     * \param stride is the stepsize, can be left out if stride = 1.
     * \param end is one past the last element, can also be mx::END to go to the last element (same as _length(0)).
     *
     * \returns an MMatrixView of the vector
     */
   MMatrixView<dataT, 1, absT, accessor_stride<1> > operator()( const size_t start, 
                                                                const size_t stride, 
                                                                const size_t end );
   
   /// Get a view (subrow) of the vector.
   /** This returns a view of the vector from element \p start to element \p end - 1, in steps
     * of size \p stride
     *
     * \param start is the first element, can also be mx::BEG to get the first element (same as 0)
     * \param end is one past the last element, can also be mx::END to go to the last element (same as _length(0)).
     *
     * \returns an MMatrixView of the vector
     */
   MMatrixView<dataT, 1, absT, accessor_vector<1> > operator()( const size_t start, 
                                                                const size_t end );
  
   /** \cond */
   //These overrides implement BEG and END boundaries, and stride=1 versions.
   
   ///Return the whole vector as a view.
   MMatrixView<dataT, 1, absT, accessor_vector<1> > operator()();
   
   
   MMatrixView<dataT, 1, absT, accessor_stride<1> > operator()( const MMatrixBound_BEG start, 
                                                                const size_t stride, 
                                                                const MMatrixBound_END end );
                                          
   MMatrixView<dataT, 1, absT, accessor_stride<1> > operator()( const size_t start, 
                                                                const size_t stride, 
                                                                const MMatrixBound_END end );
                                          
   MMatrixView<dataT, 1, absT, accessor_stride<1> > operator()( const MMatrixBound_BEG start, 
                                                                const size_t stride, 
                                                                const size_t end );
                                          
                                          
   MMatrixView<dataT, 1, absT, accessor_vector<1> > operator()( const MMatrixBound_BEG start, 
                                                                const MMatrixBound_END end );
                                          
   MMatrixView<dataT, 1, absT, accessor_vector<1> > operator()( const size_t start,  
                                                                const MMatrixBound_END end );
                                          
   MMatrixView<dataT, 1, absT, accessor_vector<1> > operator()( const MMatrixBound_BEG start, 
                                                                const size_t end );   
   /** \endcond */
   
   //@}

   /** @name Vector Arithmetic
     * \brief The dot product of two vectors
     * \details The double asterisk operator performs the dot product, which returns a single scalar.
     * Example:
     * \code
     * mx::Vectord v1 = {1, 1, 1};
     * mx::Vectord v2 = {2, 2, 2};
     * double d;
     *
     * d = v1**v2; //Now d = 6.
     * \endcode 
     */
   //@{
   
   ///\cond
   
   ///Multiplication operator is overridden for template resolution.
   template<class argT>
   MMatrix operator*(const argT & arg);
   
   ///Multiplication r-value operator is overridden for template resolution.
   template<class argT>
   MMatrix operator*(const argT && arg);
   
   ///\endcond
   
   ///The trailing half of the ** vector/matrix math operator.
   /** This converts to the pointer wrapper class \ref vector_math_temp, which exists
     * just to signal the multiplication and modulo operators that they should do matrix math, not
     * simple element-wise multiplication.
     */
   MMatrixVectorMathTemp<MMatrix<dataT, 1, absT> > operator* ();

   ///The dot or scalar product of two vectors.
   dataT operator*(MMatrixVectorMathTemp<MMatrix<dataT, 1, absT> > & vmt);

   ///The dot or scalar product of two vectors.
   dataT operator*(MMatrixVectorMathTemp<MMatrix<dataT, 1, absT> > && vmt);
   
   //@}
      
};



template<typename dataT, typename absT> 
MMatrix<dataT, 1, absT>::MMatrix()
{
   MX_MM_DEBUG_TRACE("MMatrix1::default ctor");
}

template<typename dataT, typename absT>
MMatrix<dataT, 1, absT>::MMatrix(size_t * sizes) : MMatrixBase<dataT, 1, absT, accessor_vector<1> >(sizes)
{
   MX_MM_DEBUG_TRACE("MMatrix1::ctor size_t*");
}

template<typename dataT, typename absT>
MMatrix<dataT, 1, absT>::MMatrix(const size_t * sizes) : MMatrixBase<dataT, 1, absT, accessor_vector<1> >(sizes)
{
   MX_MM_DEBUG_TRACE("MMatrix1::ctor size_t*");
}

template<typename dataT, typename absT> 
MMatrix<dataT, 1, absT>::MMatrix(const size_t size0) : MMatrixBase<dataT, 1, absT, accessor_vector<1> >(&size0)
{
   MX_MM_DEBUG_TRACE("MMatrix1::ctor size_t");
}

template<typename dataT, typename absT> 
MMatrix<dataT, 1, absT>::MMatrix(const int size0) : MMatrixBase<dataT, 1, absT, accessor_vector<1> >(&size0)
{
   MX_MM_DEBUG_TRACE("MMatrix1::ctor int");
}


template<typename dataT, typename absT> 
MMatrix<dataT, 1, absT>::MMatrix(std::initializer_list<dataT> init)
{
   MX_MM_DEBUG_TRACE("MMatrix1::ctor ilist");
   assign_ilist(init);
}

template<typename dataT, typename absT> 
template<class mmatrixT>
MMatrix<dataT, 1, absT>::MMatrix(const mmatrixT & m) : MMatrixBase<dataT, 1, absT, accessor_vector<1> >(m)
{
   MX_MM_DEBUG_TRACE("MMatrix1::ctor(const &)");
}

template<typename dataT, typename absT> 
template<class mmatrixT>
MMatrix<dataT, 1, absT>::MMatrix(mmatrixT && m) : MMatrixBase<dataT, 1, absT, accessor_vector<1> >((MMatrixBase<dataT, 1, absT, accessor_vector<1> > &&) m)
{
   MX_MM_DEBUG_TRACE("MMatrix1::ctor(&&)");
}

template<typename dataT, typename absT> 
MMatrix<dataT, 1, absT>::~MMatrix()  
{
}

template<typename dataT, typename absT> 
void MMatrix<dataT, 1, absT>::allocate(const size_t size0)
{
   allocate(&size0);   
}

template<typename dataT, typename absT> 
void MMatrix<dataT, 1, absT>::allocate(const size_t * sizes)
{
   MMatrixBase<dataT, 1, absT, accessor_vector<1> >::allocate(sizes);  
}

template<typename dataT, typename absT> 
MMatrix<dataT, 1, absT> & MMatrix<dataT, 1, absT>::operator=(const MMatrix & arg)
{ 
   MX_MM_DEBUG_TRACE("MMatrix1::operator=(&)");
   MMatrixBase<dataT, 1, absT, accessor_vector<1> >::copy(arg); 
   
   return *this;
}

template<typename dataT, typename absT> 
MMatrix<dataT, 1, absT> & MMatrix<dataT, 1, absT>::operator=(MMatrix && arg)
{ 
   MX_MM_DEBUG_TRACE("MMatrix1::operator=(&&)");
   MMatrixBase<dataT, 1, absT, accessor_vector<1> >::assign_move(arg); 
   
   return *this;
}

template<typename dataT, typename absT> 
template<class argT>
MMatrix<dataT, 1, absT> & MMatrix<dataT, 1, absT>::operator=(const argT & arg)
{ 
   MX_MM_DEBUG_TRACE("MMatrix1::operator=(&)");
   MMatrixBase<dataT, 1, absT, accessor_vector<1> >::copy(arg);
   
   return *this;
}


template<typename dataT, typename absT>
template<class argT>
MMatrix<dataT, 1, absT> & MMatrix<dataT, 1, absT>::operator=(argT && m)
{ 
   MMatrixBase<dataT, 1, absT, accessor_vector<1> >::assign_move(m); 
   
   return *this; 
}

template<typename dataT, typename absT> 
MMatrix<dataT, 1, absT> & MMatrix<dataT, 1, absT>::assign_ilist(std::initializer_list<dataT> & init)
{
   MX_MM_DEBUG_TRACE("MMatrix1::assign_ilist");
   
   allocate(init.size());
   
   typename std::initializer_list<dataT>::iterator it;
   
   size_t i = 0;
   for(it = init.begin(); it != init.end(); it++, i++)
   {
      set(&i, *it);
   }
   
   return *this;
   
}//MMatrix & assign_ilist(std::initializer_list<dataT>)

template<typename dataT, typename absT> 
MMatrix<dataT, 1, absT> & MMatrix<dataT, 1, absT>::operator=(std::initializer_list<dataT> init)
{
   MX_MM_DEBUG_TRACE("MMatrix1::operator= ilist");
   return assign_ilist(init);
}


template<typename dataT, typename absT> 
inline dataT & MMatrix<dataT, 1, absT>::operator()(const size_t d)
{ 
   return this->get(&d); //This is just as fast as the below options.
   //return this->accessor.get(this->_data, &d, this->_size_prod, this->_stride);
   //return this->_data[d]; /*This is no faster*/
}

template<typename dataT, typename absT> 
inline dataT MMatrix<dataT, 1, absT>::operator()(const size_t d) const
{ 
   return this->get(&d);
}
   
template<typename dataT, typename absT> 
inline dataT & MMatrix<dataT, 1, absT>::operator()(const MMatrixBound_BEG b)
{ 
   size_t d = 0;
   return this->get(&d);
}

template<typename dataT, typename absT> 
inline dataT MMatrix<dataT, 1, absT>::operator()(const MMatrixBound_BEG b) const 
{
   size_t d = 0;
   return this->get(&d);
}

template<typename dataT, typename absT> 
inline dataT & MMatrix<dataT, 1, absT>::operator()(MMatrixBound_LAST l)
{ 
   size_t d = this->_length[0]-1;
   return this->get(&d); 
}   

template<typename dataT, typename absT> 
inline dataT MMatrix<dataT, 1, absT>::operator()(MMatrixBound_LAST l) const 
{ 
   size_t d = this->_length[0]-1;
   return this->get(&d); 
}   
   
template<typename dataT, typename absT> 
inline MMatrixView<dataT, 1, absT, accessor_stride<1> > MMatrix<dataT, 1, absT>::get_view( const size_t start,
                                                                                           const size_t stride,
                                                                                           const size_t end )
{
   MMatrixView<dataT, 1, absT, accessor_stride<1> > vview(*this, &start, &stride, &end);
   
   return vview;
}

template<typename dataT, typename absT> 
inline MMatrixView<dataT, 1, absT, accessor_vector<1> > MMatrix<dataT, 1, absT>::get_view( const size_t start,
                                                                                           const size_t end )
{
   MMatrixView<dataT, 1, absT, accessor_vector<1> > vview(*this, &start, &end);
   
   return vview;
}


template<typename dataT, typename absT> 
MMatrixView<dataT, 1, absT, accessor_stride<1> > MMatrix<dataT, 1, absT>::operator()( const size_t start, 
                                                                                      const size_t stride, 
                                                                                      const size_t end )
{
   return get_view(start, stride, end);
}

template<typename dataT, typename absT> 
MMatrixView<dataT, 1, absT, accessor_vector<1> > MMatrix<dataT, 1, absT>::operator()( const size_t start,  
                                                                                      const size_t end )
{
   return get_view(start, end);
}



template<typename dataT, typename absT> 
MMatrixView<dataT, 1, absT, accessor_vector<1> > MMatrix<dataT, 1, absT>::operator()()
{
   return get_view(0, this->_length[0]);
}

template<typename dataT, typename absT> 
MMatrixView<dataT, 1, absT, accessor_stride<1> > MMatrix<dataT, 1, absT>::operator()( const mx::MMatrixBound_BEG start, 
                                                                                      const size_t stride, 
                                                                                      const mx::MMatrixBound_END end )
{
   std::cout << "what?\n";
   return get_view(0, stride, this->_length[0]);
}

template<typename dataT, typename absT> 
MMatrixView<dataT, 1, absT, accessor_stride<1> > MMatrix<dataT, 1, absT>::operator()( const size_t start, 
                                                                                      const size_t stride, 
                                                                                      const mx::MMatrixBound_END end )
{
   return get_view(start, stride, this->_length[0]);
}

template<typename dataT, typename absT> 
MMatrixView<dataT, 1, absT, accessor_stride<1> > MMatrix<dataT, 1, absT>::operator()( const mx::MMatrixBound_BEG start, 
                                                                                      const size_t stride, 
                                                                                      const size_t end )
{
   return get_view(0, stride, end);
}


template<typename dataT, typename absT> 
MMatrixView<dataT, 1, absT, accessor_vector<1> > MMatrix<dataT, 1, absT>::operator()( const mx::MMatrixBound_BEG start,  
                                                                                      const mx::MMatrixBound_END end )
{
   return get_view(0, this->_length[0]);
}

template<typename dataT, typename absT> 
MMatrixView<dataT, 1, absT, accessor_vector<1> > MMatrix<dataT, 1, absT>::operator()( const size_t start, 
                                                                                      const mx::MMatrixBound_END end )
{
   return get_view(start, this->_length[0]);
}

template<typename dataT, typename absT> 
MMatrixView<dataT, 1, absT, accessor_vector<1> > MMatrix<dataT, 1, absT>::operator()( const mx::MMatrixBound_BEG start, 
                                                                                      const size_t end )
{
   return get_view(0, end);
}

template<typename dataT, typename absT> 
template<class argT>
MMatrix<dataT, 1, absT> MMatrix<dataT, 1, absT>::operator*(const argT & arg)
{
   return MMatrixBase<dataT, 1, absT, accessor_vector<1> >::operator*(arg);
}
   
template<typename dataT, typename absT> 
template<class argT>
MMatrix<dataT, 1, absT> MMatrix<dataT, 1, absT>::operator*(const argT && arg)
{
   MX_MM_DEBUG_TRACE("MMatrix1::operator*(&&)");
   
//    MMatrix newmat;
//    
//    do_fobj_move<MMatrix, std::multiplies<dataT>, argT> fobj;
//    
//    fobj(*this, newmat, std::multiplies<dataT>(), arg);
//    
//    return newmat;
   
   return MMatrixBase<dataT, 1, absT, accessor_vector<1> >::operator*((const argT &&) arg);
}

   
template<typename dataT, typename absT> 
inline MMatrixVectorMathTemp<MMatrix<dataT, 1, absT> > MMatrix<dataT, 1, absT>::operator* ()
{
   MMatrixVectorMathTemp<MMatrix<dataT, 1, absT> > tmp(this);
   return tmp;
}

template<typename dataT, typename absT> 
inline dataT MMatrix<dataT, 1, absT>::operator*(MMatrixVectorMathTemp<MMatrix<dataT, 1, absT> > & vmt)
{
   dataT d = 0;
   for(size_t i=0; i < this->_meta->_length[0]; i++) 
   {
      d += this->get(&i) * vmt._vector->get(&i);
   }
   return d;
}

template<typename dataT, typename absT> 
inline dataT MMatrix<dataT, 1, absT>::operator*(MMatrixVectorMathTemp<MMatrix<dataT, 1, absT> > && vmt)
{
   return operator*( (MMatrixVectorMathTemp<MMatrix<dataT, 1, absT> > &) vmt);
}


/** \defgroup mmatrix1_typedefs Vector Typedef Declarations
  * \ingroup vmop
  * typedefs for  MMatrix<dataT, 1, absT>
  */
//@{
typedef MMatrix<bool, 1> Vectorb;///<A vector of bools.
typedef MMatrix<char, 1> Vectorc;///<A vector of chars.
typedef MMatrix<unsigned char, 1> Vectoruc; ///<A vector of unsigned chars.
typedef MMatrix<short, 1> Vectors; ///<A vector of short integers.
typedef MMatrix<unsigned short, 1> Vectorus; ///<A vector of unsigned shorts.
typedef MMatrix<int, 1> Vectori; ///<A vector of integers.
typedef MMatrix<unsigned int, 1> Vectorui; ///<A vector of unsigned integers.
typedef MMatrix<unsigned, 1> Vectoru; ///<A vector of unsigned integers (same as Vectorui, matter of taste).
typedef MMatrix<long, 1> Vectorl; ///<A vector of long integers.
typedef MMatrix<unsigned long, 1> Vectorul; ///<A vector of unsigned longs.
typedef MMatrix<long long, 1> Vectorll; ///<A vector of long long integers
typedef MMatrix<unsigned long long, 1> Vectorull; ///<A vector of unsigned long long ints.
typedef MMatrix<size_t, 1> Vectorsz; ///<A vector of size_t.  Used to return and pass indices.
typedef MMatrix<double, 1> Vectord; ///<A vector of doubles.
typedef MMatrix<float, 1> Vectorf; ///<A vector of floats.
typedef MMatrix<long double, 1> Vectorld; ///<A vector of long doubles.
typedef MMatrix<std::complex<double>, 1, double> Vectorcd; ///<A vector of complex doubles
typedef MMatrix<std::complex<float>, 1, float> Vectorcf; ///<A vector of complex floats
typedef MMatrix<std::complex<long double>, 1, long double> Vectorcld; ///<A vector of complex doubles

//@}



}; //mx

//#include "MMatrixView1"

#endif //__mx_MMatrix1__



      
      