/** \file MMatrixView1
  * \brief Declares and defines the 1-D Vector specialization of MMatrixView
  *
  * \author Jared R. Males (jaredmales@gmail.com)
  *
  */
  
#ifndef __mx_MMatrixView1__
#define __mx_MMatrixView1__

#include "MMatrix1"

namespace mx
{

template<class dataT, size_t _dim, class absT, class accessorT=accessor_stride<1> > 
class MMatrixView;

/// The Vector View Class: Partial specialization of the MMatrixView template class, for 1 dimension.
/** \ingroup vmop
  * A Vector View is a special case of a Vector, which never owns its data.  The purpose of this class
  * is to provide access to a sub-vector.  You should almost never need to explicitly construct a view.
  * 
  * \tparam dataT is the data type being stored
  * \tparam absT is the type of the absolute value of dataT (default is absT = dataT)
  */
template<class dataT, class absT, class accessorT> 
class MMatrixView<dataT, 1, absT, accessorT> : public MMatrixBase<dataT, 1, absT, accessorT>
{

public:
      
   /** @name Construction and Destruction
     * The standard MMatrixBase constructors are provided in addition to those documented here.
     */
   //@{
   
   ///Default constructor. 
   /** This does nothing.
     */
   MMatrixView();


   ///Copy constructor, in a view this is always a shallow copy.
   /** The view will point at the storage array, but will not take
     * ownership.  All meta-data is copied.
     * 
     * \param m is the MMatrix to copy
     * 
     * \tparam mmatrixT is an MMatrix type
     */
   template<class mmatrixT>
   explicit MMatrixView( const mmatrixT & m );

        
   /** \cond */
   //These are documented in MMatrixBase


   /// r-value copy constructor, in a view this is always a shallow copy.
   /** The view will point at the storage array, but will not take
     * ownership.  All meta-data is copied.
     * 
     * \param m is the MMatrixView to copy
     * 
     * \tparam mmatrixT is an MMatrix type
     */
   template<class mmatrixT>
   explicit MMatrixView( mmatrixT && m );
   
   /** \endcond */

   ///Construct from an existing MMatrix, but with a slice.
   /** Will point at the data storage and copy the meta-data, and adjust
     * the slice parameters.
     * 
     * NOTE: This version is only enabled with a stride accessor
     * 
     * \param m is the MMatrix to use
     * \param start is the new starting position
     * \param stride is the new stride
     * \param end is the new ending element
     * 
     * \tparam mmatrixT is an MMatrix type
     */
   template<class mmatrixT, class T=accessorT>
   MMatrixView( const mmatrixT & m, 
                const typename std::enable_if< !T::is_vector, size_t>::type start, 
                const size_t stride, 
                const size_t end );
   
   ///\cond
   ///Construct from an existing MMatrix, but with a slice.
   /** Will point at the data storage and copy the meta-data, and adjust
     * the slice parameters.
     * 
     * NOTE: This version is only enabled with a stride accessor
     * 
     * \param m is the MMatrix to use
     * \param starts is an array of length 1 specifying a new starting position
     * \param strides is an array of length 1 specifying the new stride
     * \param ends is an array of length 1 specifying a new ending element
     * 
     * \tparam mmatrixT is an MMatrix type
     * 
     */
   template<class mmatrixT, class T=accessorT>
   MMatrixView( const mmatrixT & m, 
                const typename std::enable_if< !T::is_vector, size_t>::type * starts, 
                const size_t * strides, 
                const size_t * ends  );
   
   ///\endcond
   
   
   ///Construct from an existing MMatrix, but with a slice.
   /** Will point at the data storage and copy the meta-data, and adjust
     * the slice parameters.
     * 
     * NOTE: This version can only be called with a vector accessor
     * 
     * \param m is the MMatrix to use
     * \param start is the new starting position
     * \param end is the new ending element
     * 
     * \tparam mmatrixT is an MMatrix type
     */
   template<class mmatrixT, class T=accessorT>
   MMatrixView( const mmatrixT & m, 
                const typename std::enable_if< T::is_vector, size_t>::type start, 
                const size_t end );
   
   ///\cond
   ///Construct from an existing MMatrix, but with a slice.
   /** Will point at the data storage and copy the meta-data, and adjust
     * the slice parameters.
     * 
     * NOTE: This version can only be called with a vector accessor
     * 
     * \param m is the MMatrix to use
     * \param starts is an array of length 1 specifying a new starting position
     * \param ends is an array of length 1 specifying a new ending element
     * 
     * \tparam mmatrixT is an MMatrix type
     */
   template<class mmatrixT, class T=accessorT>
   MMatrixView( const mmatrixT & m, 
                const typename std::enable_if< T::is_vector, size_t>::type * starts, 
                const size_t * ends  );
   
   ///\endcond
   
   ///Destructor.  If owned, the _data storage is freed.
   virtual ~MMatrixView();

   ///\endcond
   
   //@}


   
   /** @name Re-sizing
     */
   //@{
   
   /// Reset the offset, stride, and length of the view
   /** NOTE: This version can only be called with a stride accessor
     * 
     * \param start is the starting position (relative to current)
     * \param stride is the stride (relative to current)
     * \param end is the ending position (using current start and stride)
     */
   void restride( const size_t start, 
                          const size_t stride,
                          const size_t end );
      
   /** \cond */
   
   /// Reset the offset, stride, and length of the view
   /** NOTE: This version can only be called with a stride accessor
     * 
     * \param starts is an array of length 1, specifying the starting position (relative to current)
     * \param strides is an array of length 1, specifying the stride (relative to current)
     * \param ends is an array of length 1, specifying the ending position (using current start and stride)
     */
   template<class T=accessorT>
   typename std::enable_if< !T::is_vector, void>::type restride( const size_t * starts, 
                          const size_t * strides,
                          const size_t * ends );
   
   /** \endcond */
   
   /// Reset the offset, and length of the view
   /** NOTE: This version can only be called with a vector accessor
     * 
     * \param start is the starting position (relative to current)
     * \param end is the ending position (using current start and stride)
     */
   void restride( const size_t start, 
                          const size_t end );
      
   /** \cond */
   
   /// Reset the offset and length of the view
   /** NOTE: This version can only be called with a vector accessor
     * 
     * \param starts is an array of length 1, specifying the starting position (relative to current)
     * \param ends is an array of length 1, specifying the ending position (using current start and stride)
     */   
   void restride( const size_t * start, 
                          const size_t * end );
   
   /** \endcond */
   
   //@}

   /** @name Copying
     */  
   //@{
      
   ///In a view, copy only copies elements, does not change anything else.
   template<class mmatrixT>
   void copy( const mmatrixT & m );

   ///In a view, move re-points but does not take ownership.
   template<class mmatrixT>
   void move( const mmatrixT & m );

   //@}
   
   template<class mmatrixT>
   MMatrixView<dataT, 1, absT, accessorT> & operator=(const mmatrixT & m);
   
   template<class mmatrixT>
   MMatrixView<dataT, 1, absT, accessorT> & operator=(const mmatrixT && m);
                            
   //@}
   
   /** @name Element Access Operator
     */
   //@{
  
   
   /// Get a single element of the vector.
   /** This returns a single element, either as a reference or a const instance.
     *
     * \param d is the element index.  Can also be mx::BEG or mx::LAST.
     *
     * \returns type dataT
     */
   dataT & operator()( const size_t d );
   
   /** \cond */
   //Additional overloads
   dataT operator()( const size_t d ) const;   
   
   dataT & operator()( const MMatrixBound_BEG b );
   
   dataT operator()( const MMatrixBound_BEG b ) const;

   dataT & operator()( MMatrixBound_LAST l );
   
   dataT operator()( MMatrixBound_LAST l ) const;
   
   /** \endcond */
   
   //@}

   
   
   /** @name Views
     * The View operator (defined in MMatrix1) returns a subrow of the vector.
     */
   //@{

   /// Get a view (subrow) of the vector
   /** This method is called by the view operators.  
     * It should be overridden by derived classes (like MMatrixView).
     * 
     * \param start is the first element.
     * \param stride is the stepsize.
     * \param end is one past the last desired element.
     *
     * \returns an MMatrixView of the vector
     */
   MMatrixView<dataT, 1, absT, accessor_stride<1> > get_view( const size_t start, 
                                                              const size_t stride, 
                                                              const size_t end );

    
   template<class T = accessorT>
   MMatrixView<dataT, 1, absT, accessor_vector<1> > get_view( const typename std::enable_if< T::is_vector, size_t>::type start,  
                                                              const size_t end );
    
   template<class T = accessorT>
   MMatrixView<dataT, 1, absT, accessor_stride<1> > get_view( const typename std::enable_if<!T::is_vector, size_t>::type start, 
                                                              const size_t end );
    
   
   /// Get a view (subrow) of the vector.
   /** This returns a view of the vector from element \p start to element \p end - 1, in steps
     * of size \p stride
     *
     * \param start is the first element, can also be mx::BEG to get the first element (same as 0)
     * \param stride is the stepsize, can be left out if stride = 1.
     * \param end is one past the last element, can also be mx::END to go to the last element (same as _length(0)).
     *
     * \returns an MMatrixView of the vector
     */
   MMatrixView<dataT, 1, absT, accessor_stride<1> > operator()( const size_t start,  
                                                                const size_t stride, 
                                                                const size_t end );
   
   /// Get a view (subrow) of the vector.
   /** This returns a view of the vector from element \p start to element \p end - 1, in steps
     * of size \p stride
     *
     * \param start is the first element, can also be mx::BEG to get the first element (same as 0)
     * \param end is one past the last element, can also be mx::END to go to the last element (same as _length(0)).
     *
     * \returns an MMatrixView of the vector
     */
   template<class T=accessorT>
   MMatrixView<dataT, 1, absT, accessor_vector<1> > operator()( const typename std::enable_if<T::is_vector, size_t>::type start,  
                                                                const size_t end );
    
   /// Get a view (subrow) of the vector.
   /** This returns a view of the vector from element \p start to element \p end - 1, in steps
     * of size \p stride
     *
     * \param start is the first element, can also be mx::BEG to get the first element (same as 0)
     * \param end is one past the last element, can also be mx::END to go to the last element (same as _length(0)).
     *
     * \returns an MMatrixView of the vector
     */
   template<class T=accessorT>
   MMatrixView<dataT, 1, absT, accessor_stride<1> > operator()( const typename std::enable_if< !T::is_vector, size_t>::type start,  
                                                                const size_t end );
    
   ///Return the whole vector as a view.
   MMatrixView<dataT, 1, absT, accessorT> operator()();

    
   MMatrixView<dataT, 1, absT, accessor_stride<1> > operator()( const MMatrixBound_BEG start, 
                                                                const size_t stride, 
                                                                const MMatrixBound_END end );
                                          
   MMatrixView<dataT, 1, absT, accessor_stride<1> > operator()( const size_t start, 
                                                                const size_t stride, 
                                                                const MMatrixBound_END end );
                                          
   MMatrixView<dataT, 1, absT, accessor_stride<1> > operator()( const MMatrixBound_BEG start, 
                                                                const size_t stride, 
                                                                const size_t end );
  
   //The two argument operators depend different types depending on whether this is a vector or not   
   template<class T=accessorT>
   MMatrixView<dataT, 1, absT, accessor_vector<1> > operator()( 
                                                  const typename std::enable_if<T::is_vector, MMatrixBound_BEG>::type start, 
                                                  const MMatrixBound_END end );
                                          
   template<class T=accessorT>
   MMatrixView<dataT, 1, absT, accessor_vector<1> > operator()( 
                                                  const typename std::enable_if<T::is_vector, size_t>::type start, 
                                                  const MMatrixBound_END end );
   
   template<class T=accessorT>
   MMatrixView<dataT, 1, absT, accessor_vector<1> > operator()( 
                                                  const typename std::enable_if<T::is_vector, MMatrixBound_BEG>::type start, 
                                                  const size_t end );
   
   
   template<class T=accessorT>
   MMatrixView<dataT, 1, absT, accessor_stride<1> > operator()( 
                                                  const typename std::enable_if<!T::is_vector, MMatrixBound_BEG>::type start, 
                                                  const MMatrixBound_END end );
                                          
   template<class T=accessorT>
   MMatrixView<dataT, 1, absT, accessor_stride<1> > operator()( 
                                                  const typename std::enable_if<!T::is_vector, size_t>::type start, 
                                                  const MMatrixBound_END end );
   
   template<class T=accessorT>
   MMatrixView<dataT, 1, absT, accessor_stride<1> > operator()( 
                                                  const typename std::enable_if<!T::is_vector, MMatrixBound_BEG>::type start, 
                                                  const size_t end );
   
    
    
    
    
    
   //@}
   
};

template<class dataT, class absT, class accessorT> 
MMatrixView<dataT, 1, absT, accessorT>::MMatrixView()
{  
}

template<class dataT, class absT, class accessorT> 
template<class mmatrixT>
MMatrixView<dataT, 1, absT, accessorT>::MMatrixView(const mmatrixT & m)
{   
   move(m);
}

template<class dataT, class absT, class accessorT> 
template<class mmatrixT>
MMatrixView<dataT, 1, absT, accessorT>::MMatrixView(mmatrixT && m)
{
   move(m);
}



template<class dataT, class absT, class accessorT> 
template<class mmatrixT, class T>
MMatrixView<dataT, 1, absT, accessorT>::MMatrixView( const mmatrixT & m,
                                                     const typename std::enable_if< !T::is_vector, size_t>::type start,  
                                                     const size_t stride,
                                                     const size_t end )
{
   static_assert(accessorT::is_vector==false, "This MMatrixView is not stride-able.  Must use no-stride methods.");
   
   move(m);
   
   size_t start0 = m.offset(0) + start*m.stride(0);
   size_t stride0 = stride*m.stride(0);
   size_t end0 = m.offset(0) + end*m.stride(0);
   
   restride( &start0, &stride0, &end0);
}

template<class dataT, class absT, class accessorT> 
template<class mmatrixT, class T>
MMatrixView<dataT, 1, absT, accessorT>::MMatrixView( const mmatrixT & m,
                                          const typename std::enable_if< !T::is_vector, size_t>::type * start,  
                                          const size_t * stride,
                                          const size_t * end )
{
   static_assert(accessorT::is_vector==false, "This MMatrixView is not stride-able.  Must use no-stride methods.");
   
   move(m);
   
   size_t start0 = m.offset(0) + start[0]*m.stride(0);
   size_t stride0 = stride[0]*m.stride(0);
   size_t end0 = m.offset(0) + end[0]*m.stride(0);
   
   restride( &start0, &stride0, &end0);
}

template<class dataT, class absT, class accessorT> 
template<class mmatrixT, class T>
MMatrixView<dataT, 1, absT, accessorT>::MMatrixView( const mmatrixT & m,
                                                     const typename std::enable_if< T::is_vector, size_t>::type start,  
                                                     const size_t end )
{
   static_assert(accessorT::is_vector, "This MMatrixView is not a vector.  Must specify stride.");
      
   move(m);
   
   size_t start0 = m.offset(0) + start*m.stride(0);
   size_t end0 = m.offset(0) + end*m.stride(0);
   
   restride( &start0, &end0);
}

template<class dataT, class absT, class accessorT> 
template<class mmatrixT, class T>
MMatrixView<dataT, 1, absT, accessorT>::MMatrixView( const mmatrixT & m,
                                                     const typename std::enable_if< T::is_vector, size_t>::type * start, 
                                                     const size_t * end )
{
   static_assert(accessorT::is_vector, "This MMatrixView is not a vector.  Must specify stride.");
      
   move(m);
   
   size_t start0 = m.offset(0) + start[0]*m.stride(0);
   size_t end0 = m.offset(0) + end[0]*m.stride(0);
   
   restride( &start0, &end0);
}



template<class dataT, class absT, class accessorT> 
MMatrixView<dataT, 1, absT, accessorT>::~MMatrixView()  
{
}



template<class dataT, class absT, class accessorT> 
void MMatrixView<dataT, 1, absT, accessorT>::restride( const size_t start, 
                                            const size_t stride,
                                            const size_t end )
{
   restride(&start, &stride, &end);
}


template<class dataT, class absT, class accessorT> 
template<class T>
typename std::enable_if< !T::is_vector, void>::type MMatrixView<dataT, 1, absT, accessorT>::restride( const size_t * starts, 
                                                       const size_t * strides,
                                                       const size_t * ends )
{   
   
   if(this->_meta == 0 || this->_owner_meta == false) 
   {
      this->_meta = new MMatrixMeta<dataT, 1>;
      this->_owner_meta = true;
      
      this->_meta->_size_prod[0] = 1;
   }

   
   
   this->_meta->_offset[0] = starts[0];
   
   //Calculate the first element of this view.
   this->_meta->_data = &this->_block->_raw_data[this->_meta->_offset[0]];
   
   this->_meta->_stride[0] = strides[0];      
   
   //if(this->_stride[0] > 1) this->_isvector = true;
   
   this->_meta->_length[0] = ceil( (double)(ends[0] - this->_meta->_offset[0]) / this->_meta->_stride[0]);
   
   this->_meta->_tot_length = this->_meta->_length[0];
     
     
}//restride(const size_t *, const size_t *, const size_t *)

template<class dataT, class absT, class accessorT> 
void MMatrixView<dataT, 1, absT, accessorT>::restride( const size_t start, 
                                                       const size_t end )
{
   restride(&start, &end);
}


template<class dataT, class absT, class accessorT> 
void MMatrixView<dataT, 1, absT, accessorT>::restride( const size_t * starts, 
                                                       const size_t * ends )
{

   if(this->_meta == 0 || this->_owner_meta == false) 
   {
      this->_meta = new MMatrixMeta<dataT, 1>;
      this->_owner_meta = true;
      
      this->_meta->_size_prod[0] = 1;
   }
   
   this->_meta->_offset[0] = starts[0];
   
   //Calculate the first element of this view.
   this->_meta->_data = &this->_raw_data[this->_meta->_offset[0]];
   
   this->_meta->_length[0] = ends[0] - this->_meta->_offset[0];
   
   this->_meta->_tot_length = this->_meta->_length[0];
        
}//restride(const size_t *, const size_t *, const size_t *)

 
template<class dataT, class absT, class accessorT>
template<class mmatrixT>
void MMatrixView<dataT, 1, absT, accessorT>::copy( const mmatrixT & m )
{
   MX_MM_DEBUG_TRACE("MMatrixView1::copy");
      
   for(size_t index = 0; index < this->_length[0]; index++)
   {
      this->set(&index, m.get(&index));
   }
   
}//MMatrixView & copy(const MMatrixBase &) 
 
   
template<class dataT, class absT, class accessorT>
template<class mmatrixT>
void MMatrixView<dataT, 1, absT, accessorT>::move( const mmatrixT & m )
{
   MX_MM_DEBUG_TRACE("MMatrixView1::move");
   
   this->_block = m.block();
   this->_owner_block = false;
      
   this->_meta = m.meta();
   this->_owner_meta = false;
  
}

template<class dataT, class absT, class accessorT>
template<class mmatrixT>
MMatrixView<dataT, 1, absT, accessorT> & MMatrixView<dataT, 1, absT, accessorT>::operator=(const mmatrixT & m)
{
   //Check _data?
   copy((MMatrixBase<dataT, 1, absT, accessorT> &) m);
}

template<class dataT, class absT, class accessorT>
template<class mmatrixT>
MMatrixView<dataT, 1, absT, accessorT> & MMatrixView<dataT, 1, absT, accessorT>::operator=(const mmatrixT && m)
{
   //Check _data?
   copy((MMatrixBase<dataT, 1, absT, accessorT> &) m);
}


template<typename dataT, typename absT, class accessorT> 
inline dataT & MMatrixView<dataT, 1, absT, accessorT>::operator()(const size_t d)
{ 
   return this->get(&d); //This is just as fast as the below options.
   //return this->accessor.get(this->_meta->_data, &d, this->_size_prod, this->_stride);
   //return this->_meta->_data[d]; /*This is no faster*/
}

template<typename dataT, typename absT, class accessorT> 
inline dataT MMatrixView<dataT, 1, absT, accessorT>::operator()(const size_t d) const
{ 
   return this->get(&d);
}
   
template<typename dataT, typename absT, class accessorT> 
inline dataT & MMatrixView<dataT, 1, absT, accessorT>::operator()(const MMatrixBound_BEG b)
{ 
   size_t d = 0;
   return this->get(&d);
}

template<typename dataT, typename absT, class accessorT> 
inline dataT MMatrixView<dataT, 1, absT, accessorT>::operator()(const MMatrixBound_BEG b) const 
{
   size_t d = 0;
   return this->get(&d);
}

template<typename dataT, typename absT, class accessorT> 
inline dataT & MMatrixView<dataT, 1, absT, accessorT>::operator()(MMatrixBound_LAST l)
{ 
   size_t d = this->_length[0]-1;
   return this->get(&d); 
}   

template<typename dataT, typename absT, class accessorT> 
inline dataT MMatrixView<dataT, 1, absT, accessorT>::operator()(MMatrixBound_LAST l) const 
{ 
   size_t d = this->_length[0]-1;
   return this->get(&d); 
}      
   

template<typename dataT, typename absT, class accessorT> 
MMatrixView<dataT, 1, absT, accessor_stride<1> > MMatrixView<dataT, 1, absT, accessorT>::get_view( 
                                                        const size_t start,
                                                        const size_t stride,
                                                        const size_t end )
{
   MMatrixView<dataT, 1, absT, accessor_stride<1> > vview(*this, &start, &stride, &end);
   return vview;
}

template<typename dataT, typename absT, class accessorT> 
template<class T>
MMatrixView<dataT, 1, absT, accessor_vector<1> > MMatrixView<dataT, 1, absT, accessorT>::get_view( 
                                                        const typename std::enable_if< T::is_vector, size_t>::type start,  
                                                        const size_t end )
{
   MMatrixView<dataT, 1, absT, accessor_vector<1> > vview(*this, &start, &end);
   return vview;
}

template<typename dataT, typename absT, class accessorT> 
template<class T>
MMatrixView<dataT, 1, absT, accessor_stride<1> > MMatrixView<dataT, 1, absT, accessorT>::get_view( 
                                                        const typename std::enable_if<!T::is_vector, size_t>::type start,  
                                                        const size_t end )
{
   size_t stride = 1;
   MMatrixView<dataT, 1, absT, accessor_stride<1> > vview(*this, &start, &stride, &end);
   return vview;
}
 
 
template<typename dataT, typename absT, class accessorT> 
MMatrixView<dataT, 1, absT, accessor_stride<1> > MMatrixView<dataT, 1, absT, accessorT>::operator()( 
                                                             const size_t start,  
                                                             const size_t stride, 
                                                             const size_t end )
{
   return get_view(start, stride, end);
}
   
template<typename dataT, typename absT, class accessorT> 
template<class T>
MMatrixView<dataT, 1, absT, accessor_vector<1> > MMatrixView<dataT, 1, absT, accessorT>::operator()( 
                                                              const typename std::enable_if<T::is_vector, size_t>::type start,  
                                                              const size_t end )
{
   return get_view(start, end);
}

template<typename dataT, typename absT, class accessorT> 
template<class T>
MMatrixView<dataT, 1, absT, accessor_stride<1> > MMatrixView<dataT, 1, absT, accessorT>::operator()( 
                                                              const typename std::enable_if< !T::is_vector, size_t>::type start,  
                                                              const size_t end )
{
   return get_view(start, end);
}
   
template<typename dataT, typename absT, class accessorT> 
MMatrixView<dataT, 1, absT, accessorT> MMatrixView<dataT, 1, absT, accessorT>::operator()()
{
   return get_view(0, this->_length[0]);
}

template<typename dataT, typename absT, class accessorT> 
MMatrixView<dataT, 1, absT, accessor_stride<1> > MMatrixView<dataT, 1, absT, accessorT>::operator()( 
                                                                const MMatrixBound_BEG start, 
                                                                const size_t stride, 
                                                                const MMatrixBound_END end )
{
   return get_view(0, stride, this->length[0]);
}
                                          
template<typename dataT, typename absT, class accessorT> 
MMatrixView<dataT, 1, absT, accessor_stride<1> > MMatrixView<dataT, 1, absT, accessorT>::operator()( 
                                                                const size_t start, 
                                                                const size_t stride, 
                                                                const MMatrixBound_END end )
{
   return get_view(start, stride, this->length[0]);
}
                                          
template<typename dataT, typename absT, class accessorT> 
MMatrixView<dataT, 1, absT, accessor_stride<1> > MMatrixView<dataT, 1, absT, accessorT>::operator()( 
                                                                const MMatrixBound_BEG start, 
                                                                const size_t stride, 
                                                                const size_t end )
{
   return get_view(0, stride, end);
}
 
 

}; //mx

#endif //__mx_MMatrixView1__



      
      