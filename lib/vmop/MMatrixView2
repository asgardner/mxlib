/** \file MMatrixView2
  * \brief Declares and defines the 2-D Matrix specialization of MMatrixView
  *
  * \author Jared R. Males (jaredmales@gmail.com)
  *
  */
  
#ifndef __mx_MMatrixView2__
#define __mx_MMatrixView2__

#include "MMatrix2"

namespace mx
{

template<typename dataT, size_t _dim, typename absT> 
class MMatrixView;

/// The Matrix View Class: Partial specialization of the MMatrixView template class, for 2 dimensions.
/** \ingroup vmop
  * A Matrix View is a special case of a Matrix, which never owns its data.  The purpose of this class
  * is to provide access to a sub-matrix.  You should almost never need to explicitly construct a view.
  * 
  * \tparam dataT is the data type being stored
  * \tparam absT is the type of the absolute value of dataT (default is absT = dataT)
  */
template<typename dataT, typename absT> 
class MMatrixView<dataT, 2, absT> : public MMatrix<dataT, 2, absT>
{

public:
      
   /** @name Construction and Destruction
     * The standard MMatrixBase constructors are provided in addition to those documented here.
     */
   //@{
        
   ///Default constructor. 
   /** This does nothing.
     */
   MMatrixView();

   
   ///Copy constructor, in a view this is always a shallow copy.
   /** The view will point at the storage array, but will not take
     * ownership.  All meta-data is copied.
     * 
     * \param m is the MMatrixView to copy
     */
   MMatrixView( const MMatrixView<dataT, 2, absT> & m );

   /** \cond */ 
   
   ///Copy constructor, in a view this is always a shallow copy.
   /** The view will point at the storage array, but will not take
     * ownership.  All meta-data is copied.
     * 
     * This version is included to make sure this class is not bypassed
     * on construction.  May not be necessary . . .
     * 
     * \param m is the MMatrix to copy
     */
   MMatrixView( const MMatrix<dataT, 2, absT> & m );
   
   ///Copy constructor, in a view this is always a shallow copy.
   /** The view will point at the storage array, but will not take
     * ownership.  All meta-data is copied.
     * 
     * This version is included to make sure this class is not bypassed
     * on construction.  May not be necessary . . .
     * 
     * \param m is the MMatrixBase to copy
     */   
   MMatrixView( const MMatrixBase<dataT, 2, absT> & m );

   /// r-value copy constructor, in a view this is always a shallow copy.
   /** The view will point at the storage array, but will not take
     * ownership.  All meta-data is copied.
     * 
     * \param m is the MMatrixView to copy
     */
   MMatrixView( MMatrixView<dataT, 2, absT> && m );
   
   /// r-value copy constructor, in a view this is always a shallow copy.
   /** The view will point at the storage array, but will not take
     * ownership.  All meta-data is copied.
     * 
     * This version is included to make sure this class is not bypassed
     * on construction.  May not be necessary . . .
     * 
     * \param m is the MMatrix to copy
     */
   MMatrixView( MMatrix<dataT, 2, absT> && m );
   
   /// r-value copy constructor, in a view this is always a shallow copy.
   /** The view will point at the storage array, but will not take
     * ownership.  All meta-data is copied.
     * 
     * This version is included to make sure this class is not bypassed
     * on construction.  May not be necessary . . .
     * 
     * \param m is the MMatrixBase to copy
     */
   MMatrixView( MMatrixBase<dataT, 2, absT> && m );

   /** \endcond */
   
   ///Construct from an existing MMatrix, but with a slice.
   /** Will point at the data storage and copy the meta-data, and adjust
     * the slice parameters.
     * 
     * \param m is the MMatrix to use
     * \param starts is an array of length 1 specifying a new starting position
     * \param strides is an array of length 1 specifying the new stride
     * \param ends is an array of length 1 specifying a new ending element
     */
   MMatrixView( const MMatrixBase<dataT, 2, absT> & m, 
                const size_t * starts, 
                const size_t * strides, 
                const size_t * ends  );
   
   
   
   ///Construct from a c _data array.
   /** 
     * \param arr the c _data array
     * \param size0
     * \param size1
     */
   MMatrixView( dataT * arr, 
                const size_t size0,
                const size_t size1 );
   
   ///Construct from a c _data array.
   /** 
     * \param arr the c _data array
     * \param sizes holds the sizes of the array.
     */
   MMatrixView(dataT * arr, const size_t * sizes);

   ///Construct from a c _data array.
   /** 
     * \param arr the c _data array
     * \param sizes holds the sizes of the array.
     * \param offsets holds the sizes of the array.
     * \param strides holds the sizes of the array.
     */
   MMatrixView( dataT * arr, 
                const size_t * sizes, 
                const size_t * start, 
                const size_t * stride, 
                const size_t * end );
   

   /** \cond */
   ///Destructor.  If owned, the _data storage is freed.
   virtual ~MMatrixView();

   /** \endcond */
   
   //@}
    
   /** @name Re-sizing
     */
   //@{
      
   /// Resize the storage array
   /** This overrides the MMatrixBase version, no allocation occurs, just an update of the size arrays.
     *
     * \param sizes is an array of length 1
     */
   virtual void resize( const size_t * sizes );

   virtual void resize( const size_t * sizes, 
                        const size_t * start, 
                        const size_t * stride,
                        const size_t * end );   
   

   //@}
   
   /** @name Copying
     */  
   //@{
      
   ///In a view, copy only copies elements, does not change anything else.
   virtual MMatrixView<dataT, 2, absT> & copy( const MMatrixBase<dataT, 2, absT> & m );
   
   ///In a view, move re-points but does not take ownership.
   virtual MMatrixView<dataT, 2, absT> & move( const MMatrixBase<dataT, 2, absT> & m );
   
   //@}
   
   /** @name Assignment
     * 
     */  
   //@{
      
   virtual MMatrixView<dataT, 2, absT> & operator=(const MMatrixView<dataT, 2, absT> & m);
   virtual MMatrixView<dataT, 2, absT> & operator=(const MMatrix<dataT, 2, absT> & m);
   virtual MMatrixView<dataT, 2, absT> & operator=(const MMatrixBase<dataT, 2, absT> & m);
   
   virtual MMatrixView<dataT, 2, absT> & operator=(const MMatrixView<dataT, 2, absT> && m);
   virtual MMatrixView<dataT, 2, absT> & operator=(const MMatrix<dataT, 2, absT> && m);
   virtual MMatrixView<dataT, 2, absT> & operator=(const MMatrixBase<dataT, 2, absT> && m);
   
   //@}

   /** @name Raw Arrays
     */
   //@{
      
   ///Attach to a raw c/c++ array.
   /** Does not copy, rather just points to the array without taking ownership.
     * This means you are still responsible for the memory pointed to by arr.
     *
     * \param arr the c data array
     * \param sizes an array of length _dim specifying the sizes.
     */
   virtual void set_array( dataT * arr, 
                           const size_t * sizes );
                           
   ///Attach to a c data array.
   /** Does not copy, rather just points to the arra without taking ownership.
     * This means you are still responsible for the memory pointed to by arr.
     *
     * \param arr the c _data array
     * \param sizes an array of length 1 specifying the size.
     * \param start an array of length 1 specifying the starting position.
     * \param stride an array of length 1 specifying the stride.
     * \param end an array of length 1 specifying the end element
     */
   virtual void set_array( dataT * arr, 
                           const size_t * sizes,
                           const size_t * start,
                           const size_t * stride,
                           const size_t * end );
                           
   //@}
   
      
   /** @name Indexed Element Access
     * \brief Access to elements based on their 2-D coordinates
     * \details Here only overrides of idx are necessary.
     */
   //@{

   ///Get the memory offset given a coordinate.
   /** This is calculates the linear index of an array coordinate, including offset and stride.   
     *
     * \param d0 is the row
     * \param d1 is the column
     * 
     * \returns the linear index into the array.
     */
   virtual size_t idx( const size_t d0, 
                       const size_t d1 ) const;

   /** \cond */
   
   ///Get the raw index given a set of coordinates, which has length 1 in this specialization.
   /** This is calculates the linear index of an array coordinate, including offset and stride.   
     * 
     * \param d is an array of length 1 which specifies the index along each dimension
     * \returns the linear index into the _data array.
     */
   virtual size_t idx( const size_t * d ) const;

   /** \endcond */
   
   /// Get a single row of the matrix.
   /** This returns a single row.
     *
     * \param d is the row index.
     *
     * \returns a vector view, of type MMatrixView<dataT, 1, absT>
     */
   MMatrixView<dataT, 1, absT> get_row( const size_t d );
   
   /** @name Views
     * The View operator (defined in MMatrix2) returns a subrow of the vector.
     */
   //@{

   /// Get a slice (submatrix).
   /** This returns a slice from row \p start to row \p end - 1, in steps
     * of size \p stride
     *
     * \param start is the first row
     * \param stride is the stepsize
     * \param end is one past the last row
     *
     * \returns an MMatrixSlice of the matrix
     */   
   virtual MMatrixSlice<1, dataT, 2, absT> get_slice( const size_t start, 
                                                      const size_t stride, 
                                                      const size_t end );
   //@}
   
};

template<typename dataT, typename absT> 
MMatrixView<dataT, 2, absT>::MMatrixView()
{  
}

template<typename dataT, typename absT> 
MMatrixView<dataT, 2, absT>::MMatrixView(const MMatrixView<dataT, 2, absT> & m)
{
   move(m);
}

template<typename dataT, typename absT> 
MMatrixView<dataT, 2, absT>::MMatrixView(const MMatrix<dataT, 2, absT> & m)
{
   move(m);
}

template<typename dataT, typename absT> 
MMatrixView<dataT, 2, absT>::MMatrixView(const MMatrixBase<dataT, 2, absT> & m)
{
   move(m);
}

template<typename dataT, typename absT> 
MMatrixView<dataT, 2, absT>::MMatrixView(MMatrixView<dataT, 2, absT> && m)
{
   move(m);
}

template<typename dataT, typename absT> 
MMatrixView<dataT, 2, absT>::MMatrixView(MMatrix<dataT, 2, absT> && m)
{
   move(m);
}

template<typename dataT, typename absT> 
MMatrixView<dataT, 2, absT>::MMatrixView(MMatrixBase<dataT, 2, absT> && m)
{
   move(m);
}


template<class dataT, class absT> 
MMatrixView<dataT, 2, absT>::MMatrixView( const MMatrixBase<dataT, 2, absT> & m,
                                          const size_t * start,  
                                          const size_t * stride,
                                          const size_t * end )
{
   set_array(m.data(), m.size(), start, stride, end);
}

template<class dataT, class absT> 
MMatrixView<dataT, 2, absT>::MMatrixView( dataT * arr, 
                                          const size_t size0,
                                          const size_t size1 )
{
   size_t size[2];
   size_t start[2] = {};
   size_t stride[2] = {1,1};
   size_t end[2];
   
   size[0] = size0;
   size[1] = size1;
   
   end[0] = size0;
   end[1] = size1;
   
   set_array(arr, size, start, stride, end);
}


template<class dataT, class absT> 
MMatrixView<dataT, 2, absT>::MMatrixView( dataT * arr, 
                                          const size_t * sizes )
{
   size_t start[2] = {};
   size_t stride = {1,1};
   size_t end[2];
   
   end[0] = sizes[0];
   end[1] = sizes[1];
   
   set_array(arr, sizes, start, stride, end);
}

template<class dataT, class absT> 
MMatrixView<dataT, 2, absT>::MMatrixView( dataT * arr, 
                                          const size_t * sizes, 
                                          const size_t * start, 
                                          const size_t * stride,
                                          const size_t * end )
{
   set_array(arr, sizes, start, stride, end);
}



template<typename dataT, typename absT> 
MMatrixView<dataT, 2, absT>::~MMatrixView()  
{
}


template<class dataT, class absT> 
void MMatrixView<dataT, 2, absT>::resize(const size_t * sizes)
{
   resize(sizes, 0, 0, 0);
}

template<class dataT, class absT> 
void MMatrixView<dataT, 2, absT>::resize( const size_t * sizes, 
                                          const size_t * starts, 
                                          const size_t * strides,
                                          const size_t * ends )
{

   this->_isvector = false;
   this->_tot_size = 1;
   this->_tot_length = 1;
   
   for(size_t i=0;i<2; i++)
   {
      this->_size[i] = sizes[i];
   
      if( starts == 0) this->_offset[i] = 0;
      else this->_offset[i] = starts[i];
   
      if( strides == 0) this->_stride[i] = 1;
      else this->_stride[i] = strides[i];      
   
      if(this->_stride[i] > 1) this->_isvector = true;
   
      ///\todo the cast to double when calculating _length might be a problem
      //it is probably slow, and may not be able to represent all bits in a size_t
      if(ends == 0) this->_length[i] = ceil( (double)(this->_size[i] - this->_offset[i]) / this->_stride[i]);
      else this->_length[0] = ceil( (double)(ends[i] - this->_offset[i]) / this->_stride[i]);
   
      this->_tot_size *= this->_size[i];

      this->_tot_length *= this->_length[i];
     
      this->_size_prod[i] = 1;
   }
   
   this->_size_prod[0] *= this->_size[1];
   
   this->_data = &this->raw_data[this->_offset[0]*this->_size[1] + this->_offset[1]];
   
}//resize(const size_t *, const size_t *, const size_t *, const size_t *)


 
template<class dataT, class absT>
MMatrixView<dataT, 2, absT> & MMatrixView<dataT, 2, absT>::copy( const MMatrixBase<dataT, 2, absT> & m )
{
   MX_MM_DEBUG_TRACE("MMatrixView2::copy");
      
   size_t index[2];
   
   for(size_t i = 0; i < this->_length[0]; i++)
   {
      for(size_t j = 0; j < this->_length[1]; j++)
      {
         index[0] = i;
         index[1] = j;
         set(i, j, m.get(index));
      }
   }
   
   return *this;
}//MMatrixView & copy(const MMatrixBase &) 
 
   
template<class dataT, class absT>
MMatrixView<dataT, 2, absT> & MMatrixView<dataT, 2, absT>::move( const MMatrixBase<dataT, 2, absT> & m )
{
   MX_MM_DEBUG_TRACE("MMatrixView1::move");
      
   this->_raw_data = m.raw_data();
   this->_data = m.data();
   
   for(size_t i=0; i< 2; i++)
   {
      this->_size[i] = m.size(i);
      this->_offset[i] = m.offset(i);
      this->_stride[i] =  m.stride(i);
      this->_isvector = m.vector();
      this->_length[i] = m.length(i);                
   }
   
   this->_tot_size = m.total_size();
   this->_tot_length = m.total_length();
            
   return *this;
}

template<class dataT, class absT>
MMatrixView<dataT, 2, absT> & MMatrixView<dataT, 2, absT>::operator=(const MMatrixView<dataT, 2, absT> & m)
{
   //Check _data?
   copy((MMatrixBase<dataT, 2, absT> &) m);
}

template<class dataT, class absT>
MMatrixView<dataT, 2, absT> & MMatrixView<dataT, 2, absT>::operator=(const MMatrix<dataT, 2, absT> & m)
{
   //Check _data?
   copy((MMatrixBase<dataT, 2, absT> &) m);
}

template<class dataT, class absT>
MMatrixView<dataT, 2, absT> & MMatrixView<dataT, 2, absT>::operator=(const MMatrixBase<dataT, 2, absT> & m)
{
   //Check _data?
   copy((MMatrixBase<dataT, 2, absT> &) m);
}
 
template<class dataT, class absT>
MMatrixView<dataT, 2, absT> & MMatrixView<dataT, 2, absT>::operator=(const MMatrixView<dataT, 2, absT> && m)
{
   //Check _data?
   copy((MMatrixBase<dataT, 2, absT> &) m);
}

template<class dataT, class absT>
MMatrixView<dataT, 2, absT> & MMatrixView<dataT, 2, absT>::operator=(const MMatrix<dataT, 2, absT> && m)
{
   //Check _data?
   copy((MMatrixBase<dataT, 2, absT> &) m);
}

template<class dataT, class absT>
MMatrixView<dataT, 2, absT> & MMatrixView<dataT, 2, absT>::operator=(const MMatrixBase<dataT, 2, absT> && m)
{
   //Check _data?
   copy((MMatrixBase<dataT, 2, absT> &) m);
}

template<class dataT, class absT>
void MMatrixView<dataT, 2, absT>::set_array(dataT * arr, const size_t * sizes)
{
   set_array(arr, sizes, 0, 0, 0);
}

template<class dataT, class absT>
void MMatrixView<dataT, 2, absT>::set_array( dataT * arr, 
                                             const size_t * sizes, 
                                             const size_t * start, 
                                             const size_t * stride,
                                             const size_t * end )
{
   resize(sizes, start, stride, end); 
   
   this->_raw_data = arr;
   this->_owner = false;
}
   
   
template<typename dataT, typename absT> 
inline size_t MMatrixView<dataT, 2, absT>::idx( const size_t d0, 
                                                const size_t d1 ) const
{
   return d0*this->_size_prod[0]*this->_stride[0] + d1*this->_stride[1];
}

template<typename dataT, typename absT> 
inline size_t MMatrixView<dataT, 2, absT>::idx(const size_t * d) const
{
   return idx(d[0], d[1]);
}

template<typename dataT, typename absT> 
inline MMatrixView<dataT, 1, absT> MMatrixView<dataT, 2, absT>::get_row(const size_t d)
{ 
   size_t st = 1;
   size_t sz = d*this->_size[1];
   MMatrixView<dataT, 1, absT> vview(this->_raw_data, this->_size[0], &sz, &st, &this->_size[1]);
   return vview; 
}

template<typename dataT, typename absT> 
inline MMatrixSlice<1, dataT, 2, absT> MMatrixView<dataT, 2, absT>::get_slice( const size_t start, 
                                                                               const size_t stride, 
                                                                               const size_t end )
{
   MMatrixSlice<1, dataT, 2, absT> mslice(this->_data, this->_size, &start, &stride, &end);

   return mslice;
}

// template<typename dataT, typename absT> 
// inline MMatrixView<dataT, 2, absT> MMatrixView<dataT, 2, absT>::get_slice( size_t start,
//                                                                            size_t stride,
//                                                                            size_t end )
// {
//    start = this->_offset[0] + start*this->_stride[0];
//    stride = stride*this->_stride[0];
//    end = this->_offset[0] + end*this->_stride[0];
//    
//    MMatrixView<dataT, 2, absT> vview(this->_data, this->_size, &start, &stride, &end);
//    
//    return vview;
// }

}; //mx

#endif //__mx_MMatrixView1__



      
      