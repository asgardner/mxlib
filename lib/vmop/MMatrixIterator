
#ifndef __mx_MMatrixIterator__
#define __mx_MMatrixIterator__

#include <cmath>

//#include "MMatrixBase"

#define  neg_one  ( (size_t) -1) 

namespace mx
{

template<class dataT, size_t _dim, class absT, class accessorT> class MMatrixBase;

/// Increment an index, which is an array of matrix coordinates.
/** This is called by the MMatrixIterator::increment() function, but is implemented separately
  * to allow easy specialization by dimension.
  *
  * \tparam _dim is the dimension of the index
  *
  * \param _index is an array of length _dim holding the coordinates
  * \param _length is an array of length _dim specifying the max coordinate+1 of each dimension
  *
  */
template<size_t _dim>
inline void mmatrix_iterator_increment(size_t * _index, const size_t *_length)
{
   //Increment highest dimension first and return if possible
   _index[_dim-1] += 1;
   
   if(_index[_dim-1] < _length[_dim-1]) return;

   //Time to go to next dimension(s) and increment.
   _index[_dim-1] = 0;
   
   if(_dim > 1) //This is necessary to prevent size_t wraparound.  It should optimize away . . .
   {
      size_t i = _dim-2;
      while(i != neg_one)
      //for(size_t i=_dim-2;i>=0;i--)
      {
         _index[i] += 1;
      
         if(_index[i] < _length[i]) return;

         _index[i] = 0;
         
         --i;
      }
   }
   _index[0] = _length[0]; //This delivers correct "one past the end" behavior
   return;
   
}

///Specialization of mmatrix_iterator_increment for _dim = 1
template<>
inline void mmatrix_iterator_increment<1>(size_t * _index, const size_t *_length)
{
   _index[0] += 1;
   
   return;
   
}

///Specialization of mmatrix_iterator_increment for _dim = 2
template<>
inline void mmatrix_iterator_increment<2>(size_t * _index, const size_t *_length)
{
   _index[1] += 1;
   
   if(_index[1] < _length[1]) return;

   _index[1] = 0;
   
   _index[0] += 1;
 
   return;
   
}

/// Decrement an index, which is an array of matrix coordinates.
/** This is called by the MMatrixIterator::increment() function, but is implemented separately
  * to allow easy specialization by dimension.
  *
  * \tparam _dim is the dimension of the index
  *
  * \param _index is an array of length _dim holding the coordinates
  * \param _length is an array of length _dim specifying the max coordinate+1 of each dimension
  *
  */
template<size_t _dim>
inline void mmatrix_iterator_decrement(size_t * _index, size_t * _length)
{
   //Increment highest dimension first and return if possible
   _index[_dim-1] -= 1;
   if(_index[_dim-1] != neg_one) return;
   
   //Go to next dimension(s) and increment
   _index[_dim-1] = _length[_dim-1] -1;
   
   if(_dim > 1)//this is necessary to prevent size_t wraparound
   {
      size_t i = _dim-2;
      while(i != neg_one)
      //for(size_t i=_dim-2;i>=0;i--)
      {
         _index[i] -= 1;
      
         if(_index[i] != neg_one) return;

         _index[i] = _length[i]-1;
         
         --i;
      }
   }
   _index[0] = neg_one; //This delivers correct "one past the beginning" behavior
   return;
}

///Specialization of mmatrix_iterator_decrement for _dim = 1
template<>
inline void mmatrix_iterator_decrement<1>(size_t * _index, size_t * _length)
{
   _index[0] -= 1;
   return;
}

///Specialization of mmatrix_iterator_decrement for _dim = 2
template<>
inline void mmatrix_iterator_decrement<2>(size_t * _index, size_t * _length)
{
   //Increment highest dimension first and return if possible
   _index[1] -= 1;
   if(_index[1] != neg_one) return;
   
   //Go to next dimension(s) and increment
   _index[1] = _length[1] -1;
   
   _index[0] -= 1;
      
   return;
}

///Generalized iterator for moving through all elements in a MMatrix.
/** Bi-directional, meaning it can be incremented and decremented.  
  * Not random access, i.e. can't do +=2 etc.  
  * Respects stride in all dimensions.  
  * \todo test assignment and operators
  * \todo test comparison
  * \todo test dereferenced post-fix Xcrement.
  *
  * \tparam dataT is the data type stored by the matrix pointed to by the iterator
  * \tparam _dim is the dimension of the matrix pointed to by the iterator
  * \tparam absT is the data type of the absolute value of the data type of the matrix
  *
  */
template<class dataT, size_t _dim, class absT, class accessorT> 
class MMatrixIterator
{
public:
   typedef dataT data_type;
   typedef absT abs_type;
   
protected:
   
   /** \name Members
     */ 
   //@{
   
   MMatrixBase<dataT, _dim, absT, accessorT> * mat;///<Pointer to the matrix to which this iterator points
   
   size_t _index[_dim];///<Holds the current index for each dimension

   size_t _position;///<The current position in the index
      
   size_t _max_position; ///<The maximum valid value of _position
   
   //@}
   
public:

   ///Default constructor
   MMatrixIterator();
   
   ///Copy constructor
   MMatrixIterator(MMatrixIterator & mmi);

   ///r-value Copy constructor
   MMatrixIterator(MMatrixIterator && mmi);
   
   ///Construct from array of max indices
   /**
     * \param m is the MMatrixBase at which this iterator points
     * \param begin [optional] if true, then the iterator starts at the beginning.  if false, it starts at the end.
     */
   MMatrixIterator(MMatrixBase<dataT, _dim, absT, accessorT> * m, bool begin=true);
   
   ///Set to beginning of index
   void set_begin();
      
   ///set to end of index, one past the last element of the index.
   void set_end();
   
   ///Assignment operator.
   /**
     * \param mmi reference to MMatrixIterator
     * \return a reference to this
     */ 
   virtual MMatrixIterator & operator=(MMatrixIterator & mmi);
   
   ///r-value Assignment operator.
   /**
     * \param mmi reference to MMatrixIterator
     * \return a reference to this
     */ 
   virtual MMatrixIterator & operator=(MMatrixIterator && mmi);
      
   ///Equality comparison operator.
   /**
     * \param mmi is a reference to an interator
     * \returns true if compare(mmi) == 0
     */
   virtual bool operator==(MMatrixIterator & mmi);
   
   ///Not-equal comparison operator.
   /**
     * \param mmi is a reference to an interator
     * \returns true if compare(mmi) != 0
     */
   virtual bool operator!=(MMatrixIterator & mmi);
   
   ///Less-than comparison operator.
   /**
     * \param mmi is a reference to an interator
     * \returns true if compare(mmi) < 0
     */
   virtual bool operator<(MMatrixIterator & mmi);
   
   ///Less-than or equal-to comparison operator.
   /**
     * \param mmi is a reference to an interator
     * \returns true if compare(mmi) <= 0 
     */
   virtual bool operator<=(MMatrixIterator & mmi);
   
   ///Greater-than  comparison operator.
   /**
     * \param mmi is a reference to an interator
     * \returns true if compare(mmi) > 0 
     */
   virtual bool operator>(MMatrixIterator & mmi);
   
   ///Greater-than or equal-to comparison operator.
   /**
     * \param mmi is a reference to an interator
     * \returns true if compare(mmi) >= 0 
     */
   virtual bool operator>=(MMatrixIterator & mmi);

   ///Increment (+1) the iterator
   /** Adds 1 to the highest dimension (we're row-major).  If it then is >= _size[] for that dimension
     * it moves to the next dimension, and continues to until a dimension is not at _size[].  It 
     * returns as soon as possible.
     * 
     * \returns a reference to this
     */ 
   virtual MMatrixIterator & increment();
   
   ///Increment (-1) the iterator
   /** Subtracts 1 from the highest dimension (we're row-major).  If it then is < 0
     * it moves to the next dimension, and continues to until a dimension is not at -1.  It 
     * returns as soon as possible.
     * 
     * \returns a reference to this
     */ 
   virtual MMatrixIterator & decrement();
   
   ///Increment pre-fix operator
   virtual MMatrixIterator & operator++ ();
   
   ///Increment post-fix operator
   virtual MMatrixIterator  operator++ (int);
   
   ///Decrement pre-fix operator
   virtual MMatrixIterator & operator-- ();
   
   ///Decrement post-fix operator
   virtual MMatrixIterator  operator-- (int);
   
   ///Get the index, a pointer to size_t[_dim]
   virtual size_t * index();

   ///Get the maximum valid value of position
   virtual size_t position();
   
   ///Get the maximum valid value of position
   virtual size_t max();
   
   ///De-refrence operator
   virtual dataT & operator*();

   ///Structure de-reference
   virtual dataT * operator->();
   
   ///Get the pointer to the subject matrix
   MMatrixBase<dataT, _dim, absT, accessorT> * matrix() {return mat;}
};

template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixIterator<dataT, _dim, absT, accessorT>::MMatrixIterator()
{
}

template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixIterator<dataT, _dim, absT, accessorT>::MMatrixIterator(MMatrixIterator & mmi)
{
  operator=(mmi);
}

template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixIterator<dataT, _dim, absT, accessorT>::MMatrixIterator(MMatrixIterator && mmi)
{
  operator=(mmi);
}

template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixIterator<dataT, _dim, absT, accessorT>::MMatrixIterator(MMatrixBase<dataT, _dim, absT, accessorT> *m, bool begin)
{      
   mat = m;
   
   for(int i=0;i<_dim;i++)
   {
      _index[i] = 0;
   }
   
   if(begin)
   {
      _position = 0;
   }
   else
   {
      _index[0] = mat->_meta->_size[0];
      _position = mat->_meta->_tot_length;
   }
   
   _max_position = mat->_meta->_tot_length;
   
}



template<class dataT, size_t _dim, class absT, class accessorT>
void MMatrixIterator<dataT, _dim, absT, accessorT>::set_begin()
{
   for(int i=0;i<_dim;i++)
   {
      _index[i] = 0;
   }
   
   _position = 0;
}


template<class dataT, size_t _dim, class absT, class accessorT>
void MMatrixIterator<dataT, _dim, absT, accessorT>::set_end()
{

   _index[0] = mat->_meta->_size[0];
   
   for(size_t i=1;i<_dim;i++)
   {
      _index[i] = 0;
   }
   
   _position = mat->_meta->_tot_length;
}



template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixIterator<dataT, _dim, absT, accessorT> & MMatrixIterator<dataT, _dim, absT, accessorT>::operator=(MMatrixIterator<dataT, _dim, absT, accessorT> & mmi)
{
   mat = mmi.mat;
   
   for(size_t i=0;i<_dim;i++)
   {
      _index[i] = mmi._index[i];
   }
   _position = mmi._position;
   
   return *this;
}

template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixIterator<dataT, _dim, absT, accessorT> & MMatrixIterator<dataT, _dim, absT, accessorT>::operator=(MMatrixIterator<dataT, _dim, absT, accessorT> && mmi)
{
   mat = mmi.mat;
   
   for(size_t i=0;i<_dim;i++)
   {
      _index[i] = mmi._index[i];
   }
   _position = mmi._position;
   
   return *this;
}

template<class dataT, size_t _dim, class absT, class accessorT>
bool MMatrixIterator<dataT, _dim, absT, accessorT>::operator==(MMatrixIterator<dataT, _dim, absT, accessorT> & mmi)
{
   return(_position == mmi._position);
}

template<class dataT, size_t _dim, class absT, class accessorT>
bool MMatrixIterator<dataT, _dim, absT, accessorT>::operator!=(MMatrixIterator<dataT, _dim, absT, accessorT> & mmi)
{
   return(_position != mmi._position);
}

template<class dataT, size_t _dim, class absT, class accessorT>
bool MMatrixIterator<dataT, _dim, absT, accessorT>::operator<(MMatrixIterator<dataT, _dim, absT, accessorT> & mmi)
{
   return(_position < mmi._position);
}

template<class dataT, size_t _dim, class absT, class accessorT>
bool MMatrixIterator<dataT, _dim, absT, accessorT>::operator<=(MMatrixIterator<dataT, _dim, absT, accessorT> & mmi)
{
   return (_position <= mmi._position);
}

template<class dataT, size_t _dim, class absT, class accessorT>
bool MMatrixIterator<dataT, _dim, absT, accessorT>::operator>(MMatrixIterator<dataT, _dim, absT, accessorT> & mmi)
{
   return(_position > mmi._position);
}

template<class dataT, size_t _dim, class absT, class accessorT>
bool MMatrixIterator<dataT, _dim, absT, accessorT>::operator>=(MMatrixIterator<dataT, _dim, absT, accessorT> & mmi)
{
   return (_position >= mmi._position);
}

template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixIterator<dataT, _dim, absT, accessorT> & MMatrixIterator<dataT, _dim, absT, accessorT>::increment()
{
   ++_position;
   
   mmatrix_iterator_increment<_dim>(_index, mat->_meta->_length);
   
   return *this;
   
}



template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixIterator<dataT, _dim, absT, accessorT> & MMatrixIterator<dataT, _dim, absT, accessorT>::decrement()
{
   --_position;

   mmatrix_iterator_decrement<_dim>(_index, mat->_meta->_length);
   
   return *this;
}

template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixIterator<dataT, _dim, absT, accessorT> & MMatrixIterator<dataT, _dim, absT, accessorT>::operator++ ()
{
   increment();
}

template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixIterator<dataT, _dim, absT, accessorT> MMatrixIterator<dataT, _dim, absT, accessorT>::operator++ (int)
{
   MMatrixIterator tmp(*this);
   increment();
   return tmp;
}

template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixIterator<dataT, _dim, absT, accessorT> & MMatrixIterator<dataT, _dim, absT, accessorT>::operator-- ()
{
   return decrement();
}

template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixIterator<dataT, _dim, absT, accessorT> MMatrixIterator<dataT, _dim, absT, accessorT>::operator-- (int)
{
   MMatrixIterator tmp(*this);
   decrement();
   return tmp;
}

template<class dataT, size_t _dim, class absT, class accessorT>
inline size_t * MMatrixIterator<dataT, _dim, absT, accessorT>::index()
{
   return _index;
}

template<class dataT, size_t _dim, class absT, class accessorT>
inline size_t MMatrixIterator<dataT, _dim, absT, accessorT>::position()
{
   return _position;
}

template<class dataT, size_t _dim, class absT, class accessorT>
inline size_t MMatrixIterator<dataT, _dim, absT, accessorT>::max()
{
   return _max_position;
}

template<class dataT, size_t _dim, class absT, class accessorT>
inline dataT & MMatrixIterator<dataT, _dim, absT, accessorT>::operator*()
{
   return *(mat->get_ptr(_index));
}

template<class dataT, size_t _dim, class absT, class accessorT>
inline dataT * MMatrixIterator<dataT, _dim, absT, accessorT>::operator->()
{
   return mat->get_ptr(_index);
}

template<class function_object, class mmatrix_iterator>
inline void mmatrix_loop_fobj1_inplace( function_object fobj, 
                                      mmatrix_iterator & begin)
{
   typename mmatrix_iterator::data_type * ptr;
   
   while(begin.position() < begin.max())
   {
      ptr = &(*begin); //calculate address from index minimum number of times
      *ptr = fobj(*ptr);
      ++begin;
   }
}

template<class function_object, class mmatrix_iterator, class mmatrix_out>
inline void mmatrix_loop_fobj1( function_object fobj, 
                         mmatrix_out & out,
                         mmatrix_iterator & begin)
{
   while(begin.position() < begin.max())
   {
      out.set(begin.index(), fobj(*begin));
      ++begin;
   }
}

template<class function_object, class mmatrix_iterator, class argT>
inline void mmatrix_loop_fobj2_fund_inplace( function_object fobj, 
                                      mmatrix_iterator & begin,  
                                      const argT & arg)
{
   typename mmatrix_iterator::data_type * ptr;
   
   while(begin.position() < begin.max())
   {
      ptr = &(*begin); //calculate address from index only once.
      *ptr = fobj(*ptr, arg);
      ++begin;
   }
   
}

template<class function_object, class mmatrix_iterator, class mmatrix_arg>
inline void mmatrix_loop_fobj2_mmat_inplace( function_object fobj, 
                                             mmatrix_iterator & begin,  
                                             mmatrix_arg & arg)
{
   typename mmatrix_iterator::data_type * ref;
   
   while(begin.position() < begin.max())
   {
      ref = &(*begin); //Calculate address from index the minimum number of times.
      
      *ref = fobj(*ref, arg.get(begin.index()));
      ++begin;
   }
}

template<class function_object, class mmatrix_out, class mmatrix_iterator, class argT>
inline void mmatrix_loop_fobj2_fund( function_object fobj, 
                              mmatrix_out & out, 
                              mmatrix_iterator & begin, 
                              const argT & arg)
{
   while(begin.position() < begin.max())
   {
      out.set(begin.index(), fobj(*begin, arg));
      ++begin;
   }
   
}


template<class function_object, class mmatrix_out, class mmatrix_iterator, class mmatrix_arg>
inline void mmatrix_loop_fobj2_mmat( function_object fobj, 
                              mmatrix_out & out, 
                              mmatrix_iterator & begin, 
                              const mmatrix_arg & arg)
{
   while(begin.position() < begin.max())
   {
      out.set(begin.index(), fobj(*begin, arg.get(begin.index())));
      ++begin;
   }  
}

}//namespace mx

#endif  //__MMatrixIterator__




