/** \file MMatrixBase
  * \brief Declares and defines the base class for all MMatrices.
  *
  * \author Jared R. Males (jaredmales@gmail.com)
  *
  */

#ifndef __mx_MMatrixBase__
#define __mx_MMatrixBase__

#include <cstdarg>
#include <cstdlib>
#include <complex>

#include <iostream>

#include "MMConfig.h"
#include "MMatrixIterator"
#include "MMaccessor"
#include "MMfunctional"
#include "MMatrixBound"

namespace mx
{

///A storage block
template<class dataT>
struct MMatrixBlock
{
   dataT * _raw_data; ///<The raw data storage array
   
   size_t _tot_size; ///<The total size of the storage array, independent of stride.
};

///Meta data for an MMatrix
template<class dataT, size_t _dim>
struct MMatrixMeta
{
   size_t  _size[_dim];///<The raw size of each dimension
   
   size_t _size_prod[_dim]; ///<The product of sizes for the dimensions below
      
   size_t _offset[_dim];///<The offsets from the beginning of each dimension
   
   size_t  _stride[_dim]; ///<The stride of each dimension.  Strides are >= 1.
   
   dataT * _data; ///<The current starting position of the data, taking into account the offsets
   

   
   size_t _length[_dim]; ///<The apparent length of each dimension, taking stride into account.
   
   size_t _tot_length; ///<The total apparent length of the matrix, taking strides into account
};

   
///This is the base class for all MMatrix types.
/** \ingroup vmop 
  * This base class provides most of the underlying functionality of the MMatrix system.  It is not
  * intended to be used by itself, rather should only be a base class.
  *
  * The dimension of an MMatrix is hard coded via the template parameter \p _dim, which allows the compiler
  * to optimize loops and allows specialization by dimension for further optimization.
  * 
  * \tparam dataT the data type held by the mmatrix.
  * \tparam _dim is the dimension of the mmatrix.
  * \tparam absT is the data type returned by the absolute value operation.  This is to handle complex numbers.
  * \tparam accessorT specifies the MMaccessor specialization used to access the data.
  */
template<class dataT, size_t _dim, class absT, class accessorT>
class MMatrixBase
{

public:
   
   typedef bool is_mmatrix; ///<For use by the is_mmatrix test
   
   typedef dataT data_type; ///<The type stored by the matrix
   typedef absT  abs_type; ///<The type returned by the absolute value operation
   
   static const size_t dimension = _dim; ///<The dimension of the matrix.
   static const bool is_vector = accessorT::is_vector;  ///<Whether or not this is continuous in memory
   
   accessorT accessor; ///<An instance of the accessor.
   
   typedef MMatrixIterator<dataT, _dim, absT, accessorT> iterator; ///<The iterator type for this class.
   
   friend class MMatrixIterator<dataT, _dim, absT, accessorT>; ///<Allow iterators access to protected members.
   
public:
   /** @name Construction and Destruction
     */
   //@{
   
   ///Default constructor. 
   /** Initializes the non-array members but does not allocate storage.
     */
   MMatrixBase();
      
   ///Copy constructor.
   /**
     * \param m is an MMatrix to copy
     */
   MMatrixBase( const MMatrixBase & m );

   ///Move constructor.
   /** If \p m owns its storage, it is just re-pointed and ownership is adjusted.
     * 
     * \param m is an MMatrix r-value to copy
     */
   MMatrixBase( MMatrixBase && m );
      
   ///Construct and allocate the data array.
   /** The size of each dimension is specified in an array.
     * 
     * \param sizes is an array of length _dim specifying the size of each dimension
     */
   explicit MMatrixBase(size_t *sizes);

   ///Construct and allocate the data array.
   /** The size of each dimension is specified in an array.
     * 
     * \param sizes is an array of length _dim specifying the size of each dimension
     */
   explicit MMatrixBase(const size_t *sizes);
   
   explicit MMatrixBase(const int *sizes);
   
   ///Destructor.  
   /** If owned, the _data storage is freed.
     */
   virtual ~MMatrixBase();

   //@}
   
protected:
      
   /** @name Member Data
     * \brief Pointers to the data structures which describe the MMatrix.  
     * \details These are stored in structures which are then efficiently moved when possible.
     * 
     */
   //@{
   
   MMatrixBlock<dataT> * _block; ///<The storage block
   bool _owner_block; ///<ownership status of the storage block

   MMatrixMeta<dataT, _dim> * _meta; ///<The meta data
   bool _owner_meta; ///<ownership status of the meta data
   
   //@}
   
protected:

   /** @name Low-level de-allocation and initialization
     * \brief These set initial values and free memory.
     */
   //@{
      
   ///Initializes _data and _owner_block
   /** Must be called on construction to ensure free() works properly.
     */
   void initialize();
   
   ///Free the storage array.
   /** Only frees if owned.  
     */
   virtual void free();
   
   //@}
   
public:

   /** @name Allocating the matrix
     */
   //@{
         
   ///Allocate the storage array
   /** If size does not change, and the block is already owned, this does nothing.
     * 
     * \param sizes is an array of length _dim
     */  
   virtual void allocate(const size_t * sizes);
      
   //@}
   
   /** @name Copying
     */  
   //@{
     
   /// Deep Copy.
   /** Allocates memory and copies the matrix element by element.
     * 
     * \param m is the matrix to copy
     * 
     * \returns a reference to *this, which is now a fully independent matrix
     */
   template<class mmatrixT>
   void copy( const mmatrixT & m );
  
   /// Move (shallow) Copy.
   /** Merely points to the data of the matrix (its block), and points at the meta-data.
     * Takes ownership of the block and meta-data pointers if m owns them::.
     * 
     * \param m is the matrix to copy
     * 
     * \returns a reference to *this
     */
   template<class mmatrixT>
   void move( mmatrixT & m );
   
   //@}
   
   /** @name Assignment
     * 
     */  
   //@{
   
   ///Copy Assignment Method
   /** Deep copy assignment.  This is essentially just a wrapper for copy.
     * 
     */
   template<class mmatrixT>
   void assign_copy(const mmatrixT & m);
   
   ///Move Assignment Method
   /** This first checks if m owns its data.  If it does, then this takes ownership.  If m doesn't own its data, then
     * this performs a deep copy.  In either case, the result of assignment is an independent fully owned MMatrix.
     * 
     */
   template<class mmatrixT>
   void assign_move(mmatrixT & m);
   
   
   //@}
             
public:

   /** @name Member Access
     */
   //@{
   
   ///Get the dimension of the matrix.
   /** This is a compile time constant, and can also be accessed with ::dimension
     * 
     * \returns the number of dimensions of the matrix
     */
   size_t dim() const;

   ///Get value of is_vector, which tells whether memory is contiguous (i.e., whether there is a stride or not)
   /** This allows using vectorized loops instead of using tuple indexing.  This is a compile time
     * constant, and can also be accessed by ::is_vector
     *
     * \returns true if all dimensions have stride==1, false otherwise
     */ 
   bool vector() const;
   
   ///Get the address of the block
   /**
     * \returns the address of the block
     */
   MMatrixBlock<dataT> * block() const;

   ///Get the address of the raw storage array
   /**
     * \returns the address of the raw storage array
     */
   dataT * raw_data() const;

   
   ///Get the total storage size of the matrix.
   /** 
     * \returns the total storage size of the matrix
     */
   size_t total_size() const;

   ///Get the ownership status of the data storage block
   /** 
     *\returns true if this object owns the data block, false otherwise
     */
   bool owner_block() const;
   
   ///Get the address of the meta-data
   /**
     * \returns the address of the meta-data
     */
   MMatrixMeta<dataT, _dim> * meta() const; 
   
   ///Returns the size array.
   /** 
     * \returns a pointer to an array of size _dim
     */
   const size_t * size() const;
   
   ///Returns the storage size of the specified dimension, does not take stride into account.
   /** 
     * \param d is the dimension desired
     * 
     * \returns the storage size of dimension \p d
     */
   size_t size(const size_t d) const;

   ///Returns the size product of the specified dimension.
   /** 
     * \param d is the dimension desired
     * 
     * \returns the size product of dimension \p d;
     */
   size_t size_prod(size_t d) const;
      
   ///Returns the offset of the specified dimension.
   /** 
     * \param d is the dimension desired
     * 
     * \returns the offset of dimension \p d;
     */
   size_t offset(size_t d) const;
   
   ///Returns the stride of the specified dimension.
   /** 
     * \param d is the dimension desired
     * 
     * \returns the stride of dimension \p d
     */
   size_t stride(const size_t d) const;

   
   
   ///Get the total apparent length of the matrix.
   /** 
     * \returns the total apparent length of the matrix
     */
   size_t total_length() const;
  
   ///Returns the length array.
   /** 
     * \returns a pointer to an array of size _dim
     */
   const size_t * length() const;
   
   ///Returns the length of the specified dimension, taking stride into account.
   /** 
     * \param d is the dimension desired
     * 
     * \returns the length of dimension \p d
     */
   size_t length(const size_t d) const;
   
   
   ///Get the address of the storage array including the offsets
   /**
     * \returns the address of the storage array with the offsets
     */
   dataT * data() const;
      
   ///Get the ownership status of the meta data
   /** 
     *\returns true if this object owns the meta data, false otherwise
     */
   bool owner_meta() const;
   
   //@}
   
   ///Set the element at coordinates given by an array.
   /**
     * \param d is an array of length _dim holding the coordinate tuple
     * \param x is the value to set
     */ 
   void set(const size_t * d, const dataT & x);
   
   ///Get the element at coordinates given by an array.
   /**
     * \param d is an array of length _dim holding the coordinate tuple
     * 
     * \returns a reference to the element
     */ 
   dataT & get(const size_t * d);
   
   ///Get the element at coordinates given by an array, const version.
   /**
     * \param d is an array of length _dim holding the coordinate tuple
     * 
     * \returns the value of the element
     */ 
   dataT get(const size_t *d) const;

   ///Get a pointer to the element at coordinates given by an array.
   /**
     * \param d is an array of length _dim holding the coordinate tuple
     * 
     * \returns a pointer to the element
     */ 
   dataT * get_ptr(const size_t * d);
   
   //@}
   
   /** \name Direct Element Access
     * \brief Access to elements based on their raw memory offset 
     */
   //@{
      
   ///Set the element at a direct offset.
   /**
     * \param i is the relative address of the element
     * \param x is the value to set
     */ 
   void set_direct(const size_t i, const dataT & x);
   
   ///Get the element at a direct offset.
   /**
     * \param i is the relative address of the element
     * 
     * \returns a reference to the element
     */ 
   dataT & get_direct(const size_t i);
   
   ///Get the element at a direct offset, const version.
   /**
     * \param i is the relative address of the element
     * 
     * \returns a pointer to the element
     */ 
   dataT get_direct(const size_t i) const;

   ///Get a pointer to the element at a direct offset.
   /**
     * \param i is the relative address of the element
     * 
     * \returns a pointer to the element
     */
   dataT * get_ptr_direct(const size_t i);
   
   //@}
   
   /** \name Iterator Access
     * \brief Access to elements using iterators 
     */
   //@{
      
      
   MMatrixIterator<dataT, _dim, absT, accessorT> begin();
   
   MMatrixIterator<dataT, _dim, absT, accessorT> end();
   
   //@}
   
   /** \name  Element-wise Addition
     *  
     * Add a value to each element in the matrix, either a scalar or the elements in another matrix.  
     * 
     */
   //@{

   ///Add either a scalar or a matrix (element-wise), in-place.
   /** 
     * \param arg is the value to add to the matrix
     * 
     * \returns a reference to this, which is now the sum of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type     
     */
   template<class argT> 
   MMatrixBase & add_inplace(const argT & arg);
   
   ///In-place Addition operator.
   /** 
     * \param arg is the value to add to the matrix
     * 
     * \returns a reference to this, which is now the sum of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type
     */
   template<class argT>
   MMatrixBase & operator+=(const argT & arg);

   ///Add either a scalar or a matrix (element-wise), in-place.
   /**
     * \param arg is the value to add to the matrix
     * 
     * \returns a new matrix which is the sum of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type
     */
   template<class argT> 
   MMatrixBase add(const argT & arg);

   ///Addition operator.
   /** 
     * \param arg is the value to add to the matrix
     * 
     * \returns a new matrix which is the sum of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type
     */
   template<class argT>
   MMatrixBase operator+(const argT & arg);
   
   ///Add an r-value to and return a new matrix
   /** 
     * \param arg the object which to add 
     * 
     * \returns a new matrix which is the sum of the current matrix and arg, possibly re-using the storage of arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type
     */
   template<class argT> 
   MMatrixBase add(const argT && arg);
    
   ///Addition operator, r-value version.
   /** 
     * \param arg the object which to add
     * 
     * \returns a new matrix which is the sum of the current matrix and arg, possibly re-using the storage of arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type
     */
   template<class argT>
   MMatrixBase operator+(const argT && arg);
  
   //@}
   
   /** \name  Element-wise Subtract
     *  
     * Subtract a value from each element in the matrix, either a scalar or the elements in another matrix.  
     * 
     */
   //@{
      
   ///Subtract either a scalar or a matrix (element-wise), in-place.
   /** 
     * \param arg is the value to subtract from the matrix
     * 
     * \returns a reference to this, which is now the different of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type     
     */
   template<class argT> 
   MMatrixBase & sub_inplace(const argT & arg);
   
   ///In-place Subtraction operator.
   /** 
     * \param arg is the value to subtract from the matrix
     * 
     * \returns a reference to this, which is now the different of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type     
     */
   template<class argT>
   MMatrixBase & operator-=(const argT & arg);

   ///Subtract either a scalar or a matrix (element-wise).
   /**
     * \param arg is the value to subtract from the matrix
     * 
     * \returns a new matrix which is the difference of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type
     */
   template<class argT> 
   MMatrixBase sub(const argT & arg);

   ///Subtraction operator.
   /** 
     * \param arg is the value to subtract from the matrix
     * 
     * \returns a new matrix which is the difference of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type     */
   template<class argT>
   MMatrixBase operator-(const argT & arg);
   
   ///Subtract an r-value from and return a new matrix
   /** 
     * \param arg the object which to subtract 
     * 
     * \returns a new matrix which is the difference of the current matrix and arg, possibly re-using the storage of arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type
     */
   template<class argT> 
   MMatrixBase sub(const argT && arg);
    
   ///Subtraction operator, r-value version.
   /** 
     * \param arg the object which to subtract
     * 
     * \returns a new matrix which is the difference of the current matrix and arg, possibly re-using the storage of arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type
     */
   template<class argT>
   MMatrixBase operator-(const argT && arg);

   //@}
   
   /** \name  Element-wise Multiplication
     *  
     * Multiply each element in the matrix by a value, either a scalar or the elements in another matrix.  
     * 
     */
   //@{
   
   ///Multiply by either a scalar or a matrix (element-wise), in-place.
   /** 
     * \param arg is the value to multiply by the matrix
     * 
     * \returns a reference to this, which is now the product of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type     
     */
   template<class argT> 
   MMatrixBase & mult_inplace(const argT & arg);
   
   ///In-place Multiplication operator.
   /** 
     * \param arg is the value to multiply by the matrix
     * 
     * \returns a reference to this, which is now the product of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type     
     */
   template<class argT>
   MMatrixBase & operator*=(const argT & arg);

   ///Multiply by either a scalar or a matrix (element-wise).
   /**
     * \param arg is the value to multiply by the matrix
     * 
     * \returns a new matrix which is the product of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type
     */
   template<class argT> 
   MMatrixBase mult(const argT & arg);

   ///Multiplication operator.
   /** 
     * \param arg is the value to multiply by the matrix
     * 
     * \returns a new matrix which is the product of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type     
     */
   template<class argT>
   MMatrixBase operator*(const argT & arg);
   
   ///Multiply an r-value from and return a new matrix
   /** 
     * \param arg the object which to multiply by 
     * 
     * \returns a new matrix which is the product of the current matrix and arg, possibly re-using the storage of arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type
     */
   template<class argT> 
   MMatrixBase mult(const argT && arg);
    
   ///Multiplication operator, r-value version.
   /** 
     * \param arg the object which to multiply by
     * 
     * \returns a new matrix which is the product of the current matrix and arg, possibly re-using the storage of arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type
     */
   template<class argT>
   MMatrixBase operator*(const argT && arg);
   
   //@}
   
   /** \name  Element-wise Division
     *  
     * Divide each element in the matrix by a value, either a scalar or the elements in another matrix.  
     * 
     */
   //@{
      
   ///Divide by either a scalar or a matrix (element-wise), in-place.
   /** 
     * \param arg is the value to divide the matrix by
     * 
     * \returns a reference to this, which is now the ratio of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type     
     */
   template<class argT> 
   MMatrixBase & div_inplace(const argT & arg);
   
   ///In-place Division operator.
   /** 
     * \param arg is the value to divide the matrix by
     * 
     * \returns a reference to this, which is now the ratio of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type     
     */
   template<class argT>
   MMatrixBase & operator/=(const argT & arg);

   ///Divide by either a scalar or a matrix (element-wise).
   /**
     * \param arg is the value to divide the matrix by
     * 
     * \returns a new matrix which is the ratio of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type
     */
   template<class argT> 
   MMatrixBase div(const argT & arg);

   ///Division operator.
   /** 
     * \param arg is the value to divide the matrix by
     * 
     * \returns a new matrix which is the ratio of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type     
     */
   template<class argT>
   MMatrixBase operator/(const argT & arg);
   
   ///Divide by an r-value and return a new matrix
   /** 
     * \param arg the object which to divide by 
     * 
     * \returns a new matrix which is the ratio of the current matrix and arg, possibly re-using the storage of arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type
     */
   template<class argT> 
   MMatrixBase div(const argT && arg);
    
   ///Division operator, r-value version.
   /** 
     * \param arg the object which to divide by
     * 
     * \returns a new matrix which is the ratio of the current matrix and arg, possibly re-using the storage of arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type
     */
   template<class argT>
   MMatrixBase operator/(const argT && arg);
   
   //@}
   
   
   /** \name  Element-wise Modulo Division
     *  
     * Divide each element in the matrix by a value, either a scalar or the elements in another matrix, and return the remainder.  
     * 
     */
   //@{
      
   ///Divide by either a scalar or a matrix (element-wise) and return the remainder, in-place.
   /** 
     * \param arg is the value to divide the matrix by
     * 
     * \returns a reference to this, which is now the remainder after division of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type     
     */
   template<class argT> 
   MMatrixBase & mod_inplace(const argT & arg);
   
   ///In-place Modulo operator.
   /** 
     * \param arg is the value to divide the matrix by
     * 
     * \returns a reference to this, which is now the remainder after division of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type     
     */
   template<class argT>
   MMatrixBase & operator%=(const argT & arg);

   ///Divide by either a scalar or a matrix (element-wise).
   /**
     * \param arg is the value to divide the matrix by
     * 
     * \returns a new matrix which is the remainder after division of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type
     */
   template<class argT> 
   MMatrixBase mod(const argT & arg);

   ///Modulo operator.
   /** 
     * \param arg is the value to divide the matrix by
     * 
     * \returns a new matrix which is the remainder after division of the current matrix and arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type     
     */
   template<class argT>
   MMatrixBase operator%(const argT & arg);
   
   ///Divide by an r-value and return a new matrix
   /** 
     * \param arg the object which to divide by 
     * 
     * \returns a new matrix which is the remainder after division of the current matrix and arg, possibly re-using the storage of arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type
     */
   template<class argT> 
   MMatrixBase mod(const argT && arg);
    
   ///Modulo operator, r-value version.
   /** 
     * \param arg the object which to divide by
     * 
     * \returns a new matrix which is the remainder after division of the current matrix and arg, possibly re-using the storage of arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type
     */
   template<class argT>
   MMatrixBase operator%(const argT && arg);
   
   //@}
   

   /** \name  Element-wise Power
     *  
     * Take the power of each element in the matrix to a value, either a scalar or the elements in another matrix.  
     * 
     */
   //@{

   ///Take the matrix to the power of a scalar or a matrix (element-wise), in-place.
   /** 
     * \param arg is the power to which to take the matrix
     * 
     * \returns a reference to this, which is now the current matrix to the power of arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type     
     */
   template<class argT> 
   MMatrixBase & pow_inplace(const argT & arg);
   
   ///Take the matrix to the power of a scalar or a matrix (element-wise).
   /** 
     * \param arg is the power to which to take the matrix
     * 
     * \returns a new matrix, which is the current matrix to the power of arg
     * 
     * \tparam argT either an MMatrix type or an arithmetic type     
     */
   template<class argT> 
   MMatrixBase pow(const argT & arg);

   
   ///Take the matrix to the power of a scalar or a matrix (element-wise) r-value.
   /** 
     * \param arg is the power to which to take the matrix.
     * 
     * \returns a new matrix which is now the current matrix to the power of arg, re-using the storage of arg if possible.
     * 
     * \tparam argT either an MMatrix type or an arithmetic type.     
     */
   template<class argT> 
   MMatrixBase pow(const argT && arg);
   
   //@}
   
   
   /** \name  Element-wise Natural (base-e) Exponential
     *  
     * Take the base-e exponential of each element in the matrix.  
     * 
     */
   //@{
  
   ///Calculate exponential of the matrix (element-wise), in-place.
   /** 
     * \returns a reference to this
     */
   MMatrixBase & exp_inplace();
   
   /** Calculate exponential of the matrix and return a new matrix
     * 
     * \returns a new matrix
     */
   MMatrixBase exp();
   
   //@}
   
   /** \name  Element-wise Common (base-10) Exponential
     *  
     * Take the base-10 exponential of each element in the matrix.  
     * 
     */
   //@{
  
   ///Calculate exponential of the matrix (element-wise), in-place.
   /** 
     * \returns a reference to this
     */
   MMatrixBase & exp10_inplace();
   
   /** Calculate exponential of the matrix and return a new matrix
     * 
     * \returns a new matrix
     */
   MMatrixBase exp10();
   
   //@}
   
   /** \name  Element-wise Exponential
     *  
     * The exponential of each element in the matrix, where the base is either a scalar or the elements in another matrix.  
     * 
     */
   //@{

   ///Calculate the element-wise value of \f$ arg^{m} \f$, where \f$ m \f$ is the current matrix, in-place.
   /** 
     * \param arg is the base of the exponent
     * 
     * \returns a reference to this, which is now the exponentiated matrix
     * 
     * \tparam argT either an MMatrix type or an arithmetic type     
     */
   template<class argT> 
   MMatrixBase & expX_inplace(const argT & arg);
   
   ///Calculate the element-wise value of \f$ arg^{m} \f$, where \f$ m \f$ is the current matrix
   /** 
     * \param arg is the base of the exponent
     * 
     * \returns a reference to this, which is now the exponentiated matrix
     * 
     * \tparam argT either an MMatrix type or an arithmetic type     
     */
   template<class argT> 
   MMatrixBase expX(const argT & arg);

   
   ///Calculate the element-wise value of \f$ arg^{m} \f$, where \f$ m \f$ is the current matrix, r-value.
   /** 
     * \param arg is the base of the exponent
     * 
     * \returns a reference to this, which is now the exponentiated matrix
     * 
     * \tparam argT either an MMatrix type or an arithmetic type     
     */
   template<class argT> 
   MMatrixBase expX(const argT && arg);
   
   //@}
   
    /** \name  Element-wise Natural Logarithm
     *  
     * Take the logarithm of each element in the matrix.  
     * 
     */
   //@{
  
   ///Calculate the natural log of the matrix (element-wise), in-place.
   /** 
     * \returns a reference to this
     */
   MMatrixBase & log_inplace();
   
   /** Calculate natural log of the matrix and return a new matrix
     * 
     * \returns a new matrix
     */
   MMatrixBase log();
   
   //@}
   
    /** \name  Element-wise Base 10 Logarithm
     *  
     * Take the exponential of each element in the matrix.  
     * 
     */
   //@{
  
   ///Calculate base 10 log of the matrix (element-wise), in-place.
   /** 
     * \returns a reference to this
     */
   MMatrixBase & log10_inplace();
   
   /** Calculate base 10 log of the matrix and return a new matrix
     * 
     * \returns a new matrix
     */
   MMatrixBase log10();
   
   //@}
   
   /** \name  Element-wise Absolute Value
     *  
     * Take the absolute value of each element in the matrix.  
     * 
     */
   //@{
  
   ///Calculate the absolute value of the matrix (element-wise), in-place.
   /** 
     * \returns a reference to this
     */
   MMatrixBase & abs_inplace();
   
   /// Calculate the absolute value of the matrix and return a new matrix
   /** 
     * \returns a new matrix with data_type = abs_type of the calling matrix
     */
   MMatrixBase<absT, _dim, absT, accessorT> abs();
   
   //@}
   
   /** \name  Element-wise Square
     *  
     * Take the square of each element in the matrix.  
     * 
     */
   //@{
  
   ///Calculate the square of the matrix (element-wise), in-place.
   /** 
     * \returns a reference to this
     */
   MMatrixBase & square_inplace();
   
   /// Calculate the square of the matrix and return a new matrix
   /**   
     * \returns a new matrix
     */
   MMatrixBase square();
   
   //@}
   
   /** \name  Element-wise Square-Root
     *  
     * Take the square-root of each element in the matrix.  
     * 
     */
   //@{
  
   ///Calculate the square root of the matrix (element-wise), in-place.
   /** 
     * \returns a reference to this
     */
   MMatrixBase & sqrt_inplace();
   
   /// Calculate the square root of the matrix and return a new matrix
   /** 
     * \returns a new matrix
     */
   MMatrixBase sqrt();
   
   //@}
   
   /** \name  Misc. Methods
     *  
     * Misc methods for calculating various quantities of the matrix. 
     * 
     */
   //@{
  
   ///Calculate the maximum value.
   /** 
     * \returns the max value
     */
   dataT max() const;
   
   ///Calculate the minimum value.
   /** 
     * \returns the min value
     */
   dataT min() const;
   
   ///Calculate the sum of all elements.
   /** 
     * \returns the sum
     */
   dataT sum() const;
   
   ///Calculate the mean of all elements.
   /** 
     * \returns the mean
     */
   dataT mean() const;
   
   //@}
   
};

template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixBase<dataT, _dim, absT, accessorT>::MMatrixBase()
{
   MX_MM_DEBUG_TRACE("MMatrixBase::default ctor");
   
   initialize();
   
}

template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixBase<dataT, _dim, absT, accessorT>::MMatrixBase( size_t * sizes )
{
   MX_MM_DEBUG_TRACE("MMatrixBase::ctor size_t*");
   
   initialize();
   
   allocate(sizes);
}

template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixBase<dataT, _dim, absT, accessorT>::MMatrixBase( const size_t * sizes )
{
   MX_MM_DEBUG_TRACE("MMatrixBase::ctor size_t*");
   
   initialize();
   
   allocate(sizes);
}

template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixBase<dataT, _dim, absT, accessorT>::MMatrixBase( const int * sizes )
{
   MX_MM_DEBUG_TRACE("MMatrixBase::ctor size_t*");
   
   initialize();
   
   size_t sizes0[_dim];
   for(size_t i=0;i<_dim;i++) sizes0[i] = sizes[i];
   
   allocate(sizes0);
}

template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixBase<dataT, _dim, absT, accessorT>::MMatrixBase( const MMatrixBase & m )
{
   MX_MM_DEBUG_TRACE("MMatrixBase::copy ctor &");
   
   initialize();

   copy(m);
}


template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixBase<dataT, _dim, absT, accessorT>::MMatrixBase(MMatrixBase && m)
{
   MX_MM_DEBUG_TRACE("MMatrixBase::copy ctor &&");
   
   initialize();

   //Result of construction should always be ownership.
   if(m._owner_block)
   {
      move(m);
   }
   else
   {
      copy(m);
   }
}

template<class dataT, size_t _dim, class absT, class accessorT>
MMatrixBase<dataT, _dim, absT, accessorT>::~MMatrixBase()
{
   MX_MM_DEBUG_TRACE("MMatrixBase::dtor");
   
   free();  
   
   if(_meta && _owner_meta) delete _meta;
}

template<class dataT, size_t _dim, class absT, class accessorT>
inline void MMatrixBase<dataT, _dim, absT, accessorT>::initialize()
{  
   MX_MM_DEBUG_TRACE("MMatrixBase::initialize");
   
   _block = 0;
   
   _owner_block = false;
  
   _meta = 0;
   
   _owner_meta = false;
   
}//void initialize()

template<class dataT, size_t _dim, class absT, class accessorT> 
inline void MMatrixBase<dataT, _dim, absT, accessorT>::free()
{
   MX_MM_DEBUG_TRACE("MMatrixBase::free");
   
   if(_block && _owner_block)
   {
      MX_MM_DEBUG_TRACE("MMatrixBase::free-deleting");
      
      //if(_block->_raw_data) //We're going to assume that _block isn't allocated without _raw_data being allocated
      delete[] _block->_raw_data;
      delete _block;
      
      _owner_block = false;
      _block = 0;
   }
}


template<class dataT, size_t _dim, class absT, class accessorT>
void MMatrixBase<dataT, _dim, absT, accessorT>::allocate(const size_t * sizes)
{
   MX_MM_DEBUG_TRACE("MMatrixBase::allocate");
   
   size_t old_size, new_size;
   
   //This decides whether we allocate if size changes
   //If _block isn't allocate or this instance doesn't own the _block, we will allocate
   //Otherwise, we only allocate if _tot_size changes
   if(_block != 0 && _owner_block == true)  old_size = _block->_tot_size;
   else old_size = 0;
   
   //Update meta data;
   
   if(_meta == 0 || _owner_meta == false) 
   {
      _meta = new MMatrixMeta<dataT, _dim>;
      _owner_meta = true;
   }
   
   new_size = sizes[0];
   
   _meta->_offset[0] = 0;
   _meta->_stride[0] = 1;
   _meta->_length[0] = sizes[0];
   
   _meta->_size_prod[0] = 1;//sizeof(dataT);
   
   for(size_t i=1;i<_dim;i++)
   {
      new_size *= sizes[i];
            
      _meta->_size[i] = sizes[i];
      
      _meta->_offset[i] = 0;
      _meta->_stride[i] = 1;
      _meta->_length[i] = sizes[i];
      
      _meta->_size_prod[i] = 1;//sizeof(dataT);
   }

   for(size_t i=0; i < _dim; i++)
   {
      for(size_t j=i+1; j<_dim;j++)
      {
         _meta->_size_prod[i] *= _meta->_size[j];
      }
   }
   
   _meta->_tot_length = new_size;
   
   //And now allocate the storage array, if necessary
   if(new_size != old_size)// || _block == 0 || _owner_block == false)
   {
      free();

      _block = new MMatrixBlock<dataT>;
      _owner_block = true;
   
      _block->_raw_data = new dataT[new_size];
      _block->_tot_size = new_size;
   
   }
   
   _meta->_data = _block->_raw_data;
   
}//void allocate(size_t *)

template<class dataT, size_t _dim, class absT, class accessorT>
template<class mmatrixT>
void MMatrixBase<dataT, _dim, absT, accessorT>::copy( const mmatrixT & m )
{
   MX_MM_DEBUG_TRACE("MMatrixBase::copy");
   
   //Test for self-assignment
   if(this == &m) return;
  
   size_t sizes[_dim];
      
   for(size_t i=0;i<_dim;i++) sizes[i] = m._meta->_length[i];
      
   //Don't free, let allocate decide if it's necessary.
   allocate(sizes);

   do_fobj_inplace<MMatrixBase<dataT, _dim, absT, accessorT>, mx::copy<dataT>, mmatrixT> fobj;
   fobj(*this, mx::copy<dataT>(), m);
   
}//MMatrixBase & copy(const MMatrixBase &)

template<class dataT, size_t _dim, class absT, class accessorT>
template<class mmatrixT>
void MMatrixBase<dataT, _dim, absT, accessorT>::move( mmatrixT & m )
{
   MX_MM_DEBUG_TRACE("MMatrixBase::move");
      
   //Test for self-assignment
   if(this == &m) return;
   
   //Check to make sure this doesn't currently own allocated memory
   free();

   //Point at m's block, and take ownership if necessary
   _block = m._block;
   
   if(m._owner_block) 
   {
      m._owner_block = false;
      _owner_block = true;
   }
   else _owner_block = false;//If m doesn't own it, then this can't either

   //Point at m's meta data, and take ownership if necessary
   _meta = m._meta;
   
   if(m._owner_meta) 
   {
      m._owner_meta = false;
      _owner_meta = true;
   }
   else _owner_meta = false;
         
   return;
}//MMatrixBase & move(const MMatrixBase &)

template<class dataT, size_t _dim, class absT, class accessorT>
template<class mmatrixT>
void MMatrixBase<dataT, _dim, absT, accessorT>::assign_copy(const mmatrixT & m)
{ 
   MX_MM_DEBUG_TRACE("MMatrixBase::assign_copy");
   
   copy(m);
   
   return;
}

template<class dataT, size_t _dim, class absT, class accessorT>
template<class mmatrixT>
void MMatrixBase<dataT, _dim, absT, accessorT>::assign_move(mmatrixT & m)
{ 
   MX_MM_DEBUG_TRACE("MMatrixBase::assign_move");
   
   //Result of assignment should always be ownership by default
   if(m._owner_block)
   {
      move(m);
   }
   else
   {
      copy(m);
   }
   
   return;
}

template<class dataT, size_t _dim, class absT, class accessorT>
inline size_t MMatrixBase<dataT, _dim, absT, accessorT>::dim() const
{
   return  _dim;
}

template<class dataT, size_t _dim, class absT, class accessorT>
inline bool MMatrixBase<dataT, _dim, absT, accessorT>::vector() const 
{
   return is_vector;
}

template<class dataT, size_t _dim, class absT, class accessorT>
inline MMatrixBlock<dataT> * MMatrixBase<dataT, _dim, absT, accessorT>::block() const
{
   return  _block;
}

template<class dataT, size_t _dim, class absT, class accessorT>
inline dataT * MMatrixBase<dataT, _dim, absT, accessorT>::raw_data() const
{ 
   if(_block) return _block->_raw_data;
   
   return 0;
}

template<class dataT, size_t _dim, class absT, class accessorT>
inline size_t MMatrixBase<dataT, _dim, absT, accessorT>::total_size() const
{ 
   if(_block)   return _block->_tot_size;
   
   return 0;
}

template<class dataT, size_t _dim, class absT, class accessorT>
inline bool MMatrixBase<dataT, _dim, absT, accessorT>::owner_block() const
{ 
   return _owner_block;
}


template<class dataT, size_t _dim, class absT, class accessorT>
inline MMatrixMeta<dataT, _dim> * MMatrixBase<dataT, _dim, absT, accessorT>::meta() const
{ 
   return _meta;
}

template<class dataT, size_t _dim, class absT, class accessorT>
inline const size_t * MMatrixBase<dataT, _dim, absT, accessorT>::size() const
{ 
   if(_meta) return _meta->_size;
   
   return 0;
}
   
template<class dataT, size_t _dim, class absT, class accessorT>
inline size_t MMatrixBase<dataT, _dim, absT, accessorT>::size(const size_t d) const 
{ 
   if(_meta) return _meta->_size[d];
   
   return 0;
}
 
template<class dataT, size_t _dim, class absT, class accessorT>
inline size_t MMatrixBase<dataT, _dim, absT, accessorT>::size_prod(const size_t d) const 
{ 
   if(_meta) return _meta->_size_prod[d];
   
   return 0;
}

template<class dataT, size_t _dim, class absT, class accessorT>
inline size_t MMatrixBase<dataT, _dim, absT, accessorT>::offset(size_t d) const
{
   if(_meta) return _meta->_offset[d];
   
   return 0;
}
   
template<class dataT, size_t _dim, class absT, class accessorT>
inline size_t MMatrixBase<dataT, _dim, absT, accessorT>::stride(const size_t d) const
{ 
   if(_meta) return _meta->_stride[d];
   
   return 0;
}

template<class dataT, size_t _dim, class absT, class accessorT>
inline size_t MMatrixBase<dataT, _dim, absT, accessorT>::total_length() const
{ 
   if(_meta) return _meta->_tot_length;
   
   return 0;
}
   
template<class dataT, size_t _dim, class absT, class accessorT>
inline const size_t * MMatrixBase<dataT, _dim, absT, accessorT>::length() const
{ 
   if(_meta) return _meta->_length;
   
   return 0;
}
   
template<class dataT, size_t _dim, class absT, class accessorT>
inline size_t MMatrixBase<dataT, _dim, absT, accessorT>::length(const size_t d) const 
{ 
   if(_meta) return _meta->_length[d];
   
   return 0;
}



template<class dataT, size_t _dim, class absT, class accessorT>
inline dataT * MMatrixBase<dataT, _dim, absT, accessorT>::data() const
{ 
   if(_meta) return _meta->_data;
   
   return 0;
}
 
template<class dataT, size_t _dim, class absT, class accessorT>
inline bool MMatrixBase<dataT, _dim, absT, accessorT>::owner_meta() const
{ 
   return _owner_meta;
}


template<class dataT, size_t _dim, class absT, class accessorT> 
inline void MMatrixBase<dataT, _dim, absT, accessorT>::set(const size_t *d, const dataT & x)
{
   accessor.set(_meta->_data, d, _meta->_size_prod, _meta->_stride, x);
}

template<class dataT, size_t _dim, class absT, class accessorT> 
inline dataT &  MMatrixBase<dataT, _dim, absT, accessorT>::get(const size_t *d)
{
   return accessor.get(_meta->_data, d, _meta->_size_prod, _meta->_stride);
}

template<class dataT, size_t _dim, class absT, class accessorT> 
inline dataT  MMatrixBase<dataT, _dim, absT, accessorT>::get(const size_t *d) const
{
   return accessor.get(_meta->_data, d, _meta->_size_prod, _meta->_stride);
}

template<class dataT, size_t _dim, class absT, class accessorT> 
inline dataT * MMatrixBase<dataT, _dim, absT, accessorT>::get_ptr(const size_t * d)
{
   return &accessor.get(_meta->_data, d, _meta->_size_prod, _meta->_stride);
}

template<class dataT, size_t _dim, class absT, class accessorT> 
inline void MMatrixBase<dataT, _dim, absT, accessorT>::set_direct(const size_t i, const dataT & x)
{
   _meta->_data[i] = x;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
inline dataT &  MMatrixBase<dataT, _dim, absT, accessorT>::get_direct(const size_t i)
{
   return _meta->_data[i];
}

template<class dataT, size_t _dim, class absT, class accessorT> 
inline dataT  MMatrixBase<dataT, _dim, absT, accessorT>::get_direct(const size_t i) const
{
   return _meta->_data[i];
}

template<class dataT, size_t _dim, class absT, class accessorT> 
inline dataT * MMatrixBase<dataT, _dim, absT, accessorT>::get_ptr_direct(const size_t i)
{
   return &_meta->_data[i];
}

//--------------------------------------------//
//---------- Iterators -------------------//

template<class dataT, size_t _dim, class absT, class accessorT> 
MMatrixIterator<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::begin()
{
   MMatrixIterator<dataT, _dim, absT, accessorT> itb(this, true);
   return itb;
}
   
template<class dataT, size_t _dim, class absT, class accessorT> 
MMatrixIterator<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::end()
{
   MMatrixIterator<dataT, _dim, absT, accessorT> ite(this, false);
   return ite;
}
   
//-----------------------------------------------//
// --------       addition  ---------------//

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
inline MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::add_inplace(const argT & arg)
{
   do_fobj_inplace<MMatrixBase<dataT, _dim, absT, accessorT>, std::plus<dataT>, argT> fobj;
   fobj(*this, std::plus<dataT>(), arg);
   return *this;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::operator+=(const argT & arg)
{ 
   return add_inplace(arg); 
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT> 
inline MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::add(const argT & arg)
{
   MMatrixBase newmat(_meta->_length);

   do_fobj<MMatrixBase, std::plus<dataT>, argT> fobj;
   
   fobj(*this, newmat, std::plus<dataT>(), arg);
   
   return newmat;
}//add(const argT &)

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::operator+(const argT & arg)
{
   return add(arg);
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT> 
inline MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::add(const argT && arg)
{
   MMatrixBase newmat;

   std::cout << "r-value add\n";
   
   do_fobj_move<MMatrixBase, std::plus<dataT>, argT> fobj;
   
   fobj(*this, newmat, std::plus<dataT>(), arg);
   
   return newmat;
}//add(const argT &&)


template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::operator+(const argT && arg)
{
   return add( (const argT &&) arg);
}

//-----------------------------------------------//
// --------       Subtraction  ---------------//

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
inline MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::sub_inplace(const argT & arg)
{
   do_fobj_inplace<MMatrixBase<dataT, _dim, absT, accessorT>, std::minus<dataT>, argT> fobj;
   fobj(*this, std::minus<dataT>(), arg);
   return *this;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::operator-=(const argT & arg)
{ 
   return sub_inplace(arg); 
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT> 
inline MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::sub(const argT & arg)
{
   MMatrixBase newmat(_meta->_length);

   do_fobj<MMatrixBase, std::minus<dataT>, argT> fobj;
   
   fobj(*this, newmat, std::minus<dataT>(), arg);
   
   return newmat;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::operator-(const argT & arg)
{
   return sub(arg);
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT> 
inline MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::sub(const argT && arg)
{
   MMatrixBase newmat;
   
   do_fobj_move<MMatrixBase, std::minus<dataT>, argT> fobj;
   
   fobj(*this, newmat, std::minus<dataT>(), arg);
   
   return newmat;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::operator-(const argT && arg)
{
   return sub( (const argT &&) arg);
}

//-----------------------------------------------//
// --------       Multiplication  ---------------//

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
inline MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::mult_inplace(const argT & arg)
{
   do_fobj_inplace<MMatrixBase<dataT, _dim, absT, accessorT>, std::multiplies<dataT>, argT> fobj;
   fobj(*this, std::multiplies<dataT>(), arg);
   return *this;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::operator*=(const argT & arg)
{ 
   return mult_inplace(arg); 
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT> 
inline MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::mult(const argT & arg)
{
   MX_MM_DEBUG_TRACE("MMatrixBase::mult(&)");
   
   MMatrixBase newmat(_meta->_length);

   std::cout << "1\n";
   do_fobj<MMatrixBase, std::multiplies<dataT>, argT> fobj;
   std::cout << "2\n";
   fobj(*this, newmat, std::multiplies<dataT>(), arg);
   std::cout << "3\n";
   return newmat;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::operator*(const argT & arg)
{
   MX_MM_DEBUG_TRACE("MMatrixBase::operator*(&)");
   return mult(arg);
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT> 
inline MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::mult(const argT && arg)
{
   MX_MM_DEBUG_TRACE("MMatrixBase::mult(&&)");
   MMatrixBase newmat;
   std::cout << "1\n";
   do_fobj_move<MMatrixBase, std::multiplies<dataT>, argT> fobj;
   std::cout << "2\n";
   fobj(*this, newmat, std::multiplies<dataT>(), arg);
   std::cout << "3\n";
   return newmat;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::operator*(const argT && arg)
{
    MX_MM_DEBUG_TRACE("MMatrixBase::operator*(&&)");
   return mult((const argT &&)arg);
}

//-----------------------------------------------//
// --------          Division     ---------------//

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
inline MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::div_inplace(const argT & arg)
{
   do_fobj_inplace<MMatrixBase<dataT, _dim, absT, accessorT>, std::divides<dataT>, argT> fobj;
   fobj(*this, std::divides<dataT>(), arg);
   return *this;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::operator/=(const argT & arg)
{ 
   return div_inplace(arg); 
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT> 
inline MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::div(const argT & arg)
{
   MMatrixBase newmat(_meta->_length);

   do_fobj<MMatrixBase, std::divides<dataT>, argT> fobj;
   
   fobj(*this, newmat, std::divides<dataT>(), arg);
   
   return newmat;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::operator/(const argT & arg)
{
   return div(arg);
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT> 
inline MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::div(const argT && arg)
{
   MMatrixBase newmat;

   std::cout << "r-value div\n";
   
   do_fobj_move<MMatrixBase, std::divides<dataT>, argT> fobj;
   
   fobj(*this, newmat, std::divides<dataT>(), arg);
   
   return newmat;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::operator/(const argT && arg)
{
   return div( (const argT &&) arg);
}

//-----------------------------------------------//
// --------          Modulus     ---------------//

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
inline MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::mod_inplace(const argT & arg)
{
   do_fobj_inplace<MMatrixBase<dataT, _dim, absT, accessorT>, mx::fmodulo<dataT>, argT> fobj;
   fobj(*this, mx::fmodulo<dataT>(), arg);
   return *this;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::operator%=(const argT & arg)
{ 
   return mod_inplace(arg); 
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT> 
inline MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::mod(const argT & arg)
{
   MMatrixBase newmat(_meta->_length);

   do_fobj<MMatrixBase, mx::fmodulo<dataT>, argT> fobj;
   
   fobj(*this, newmat, mx::fmodulo<dataT>(), arg);
   
   return newmat;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::operator%(const argT & arg)
{
   return mod(arg);
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT> 
inline MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::mod(const argT && arg)
{
   MMatrixBase newmat;

   std::cout << "r-value mod\n";
   
   do_fobj_move<MMatrixBase, mx::fmodulo<dataT>, argT> fobj;
   
   fobj(*this, newmat, mx::fmodulo<dataT>(), arg);
   
   return newmat;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::operator%(const argT && arg)
{
   return mod( (const argT &&) arg);
}

//-----------------------------------------------//
// --------          Power     ---------------//

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
inline MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::pow_inplace(const argT & arg)
{
   do_fobj_inplace<MMatrixBase<dataT, _dim, absT, accessorT>, mx::power<dataT>, argT> fobj;
   fobj(*this, mx::power<dataT>(), arg);
   return *this;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT> 
inline MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::pow(const argT & arg)
{
   MMatrixBase newmat(_meta->_length);

   do_fobj<MMatrixBase, mx::power<dataT>, argT> fobj;
   
   fobj(*this, newmat, mx::power<dataT>(), arg);
   
   return newmat;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT> 
inline MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::pow(const argT && arg)
{
   MMatrixBase newmat;

   std::cout << "r-value pow\n";
   
   do_fobj_move<MMatrixBase, mx::power<dataT>, argT> fobj;
   
   fobj(*this, newmat, mx::power<dataT>(), arg);
   
   return newmat;
}

//-----------------------------------------------//
// --------          Exp      ---------------//

template<class dataT, size_t _dim, class absT, class accessorT> 
MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::exp_inplace()
{
   loop1_inplace(*this, mx::exp<dataT>(), 0);   
}

template<class dataT, size_t _dim, class absT, class accessorT> 
MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::exp()
{
   MMatrixBase newmat(_meta->_length);

   loop1(*this, newmat, mx::exp<dataT>(), 0);
   
   return newmat;
}

//-----------------------------------------------//
// --------          Exp10      ---------------//

template<class dataT, size_t _dim, class absT, class accessorT> 
MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::exp10_inplace()
{
   loop1_inplace(*this, mx::exp10<dataT>(), 0);   
}

template<class dataT, size_t _dim, class absT, class accessorT> 
MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::exp10()
{
   MMatrixBase newmat(_meta->_length);

   loop1(*this, newmat, mx::exp10<dataT>(), 0);
   
   return newmat;
}


//-----------------------------------------------//
// --------          expX     ---------------//

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT>
inline MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::expX_inplace(const argT & arg)
{
   do_fobj_inplace<MMatrixBase<dataT, _dim, absT, accessorT>, mx::expX<dataT>, argT> fobj;
   fobj(*this, mx::expX<dataT>(), arg);
   return *this;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT> 
inline MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::expX(const argT & arg)
{
   MMatrixBase newmat(_meta->_length);

   do_fobj<MMatrixBase, mx::expX<dataT>, argT> fobj;
   
   fobj(*this, newmat, mx::expX<dataT>(), arg);
   
   return newmat;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
template<class argT> 
inline MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::expX(const argT && arg)
{
   MMatrixBase newmat;

   std::cout << "r-value expX\n";
   
   do_fobj_move<MMatrixBase, mx::expX<dataT>, argT> fobj;
   
   fobj(*this, newmat, mx::expX<dataT>(), arg);
   
   return newmat;
}




//-----------------------------------------------//
// --------          log     ---------------//

template<class dataT, size_t _dim, class absT, class accessorT> 
MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::log_inplace()
{
   loop1_inplace(*this, mx::log<dataT>(), 0);
}

template<class dataT, size_t _dim, class absT, class accessorT> 
MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::log()
{
   MMatrixBase newmat(_meta->_length);

   loop1(*this, newmat, mx::log<dataT>(), 0);
   
   return newmat;
}

//-----------------------------------------------//
// --------          log10     ---------------//

template<class dataT, size_t _dim, class absT, class accessorT> 
MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::log10_inplace()
{
   loop1_inplace(*this, mx::log10<dataT>(), 0);
}

template<class dataT, size_t _dim, class absT, class accessorT> 
MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::log10()
{
   MMatrixBase newmat(_meta->_length);

   loop1(*this, newmat, mx::log10<dataT>(), 0);
   
   return newmat;
}

//-----------------------------------------------//
// --------          Abs     ---------------//

template<class dataT, size_t _dim, class absT, class accessorT> 
MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::abs_inplace()
{
   loop1_inplace(*this, mx::abs<dataT, dataT>(),0);
}

template<class dataT, size_t _dim, class absT, class accessorT> 
MMatrixBase<absT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::abs()
{
   MMatrixBase<absT, _dim, absT, accessorT> newmat(_meta->_length);

   loop1(*this, newmat, mx::abs<absT, dataT>(), 0);
   
   return newmat;
}

//-----------------------------------------------//
// --------          Square     ---------------//

template<class dataT, size_t _dim, class absT, class accessorT> 
MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::square_inplace()
{
   loop1_inplace(*this, mx::square<dataT>(), 0);
}

template<class dataT, size_t _dim, class absT, class accessorT> 
MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::square()
{
   MMatrixBase newmat(_meta->_length);

   loop1(*this, newmat, mx::square<dataT>() ,0);
   
   return newmat;  
}

//-----------------------------------------------//
// --------      Square root     ---------------//

template<class dataT, size_t _dim, class absT, class accessorT> 
MMatrixBase<dataT, _dim, absT, accessorT> & MMatrixBase<dataT, _dim, absT, accessorT>::sqrt_inplace()
{
   loop1_inplace(*this, mx::sqrt<dataT>(), 0);
}

template<class dataT, size_t _dim, class absT, class accessorT> 
MMatrixBase<dataT, _dim, absT, accessorT> MMatrixBase<dataT, _dim, absT, accessorT>::sqrt()
{
   MMatrixBase newmat(_meta->_length);

   loop1(*this, newmat, mx::sqrt<dataT>(), 0);
   
   return newmat;
}

//-----------------------------------------------//
// --------          Max     ---------------//

template<class dataT, size_t _dim, class absT, class accessorT> 
dataT MMatrixBase<dataT, _dim, absT, accessorT>::max() const
{
   size_t index[_dim] = {};
         
   dataT _tmp, _max=get(index);
   
   mmatrix_index_increment<_dim>(index, _meta->_length);
   
   while(index[0] < _meta->_length[0])
   {
      _tmp = get(index);
      
      if(_tmp > _max) _max = _tmp;
      
      mmatrix_index_increment<_dim>(index, _meta->_length);
   }
   
   return _max;
}
   
template<class dataT, size_t _dim, class absT, class accessorT> 
dataT MMatrixBase<dataT, _dim, absT, accessorT>::min() const
{
   size_t index[_dim] = {};
         
   dataT _tmp, _min=get(index);
   
   mmatrix_index_increment<_dim>(index, _meta->_length);
   
   while(index[0] < _meta->_length[0])
   {
      _tmp = get(index);
      if(_tmp < _min) _min = _tmp;
      
      mmatrix_index_increment<_dim>(index, _meta->_length);
   }
   
   return _min;
}
 
template<class dataT, size_t _dim, class absT, class accessorT> 
dataT MMatrixBase<dataT, _dim, absT, accessorT>::sum() const
{
   size_t index[_dim] = {};
         
   dataT _sum=get(index);
   
   mmatrix_index_increment<_dim>(index, _meta->_length);
   
   while(index[0] < _meta->_length[0])
   {
      _sum += get(index);
      
      mmatrix_index_increment<_dim>(index, _meta->_length);
   }
   
   return _sum;
//   dataT * d = _meta->_data;
   
//    dataT _sum = _meta->_data[0];
//    
//    for(size_t i=1; i < _meta->_tot_length; i++) _sum += _meta->_data[i];
//    
//    return _sum;
}

template<class dataT, size_t _dim, class absT, class accessorT> 
dataT MMatrixBase<dataT, _dim, absT, accessorT>::mean() const
{
   return sum()/_meta->_tot_length;
}
 
 
 
 
 
///\cond
///This recursive function is called by the stream insertion operator, and itself, to format an MMatrixBase for output.
template<class dataT, size_t _dim, class absT, class accessorT> 
void mmatrix_output_worker ( std::ostream& os, 
                             typename MMatrixBase<dataT,_dim,absT,accessorT>::iterator & it, 
                             size_t curr_dim)
{

   if(curr_dim < _dim-1)
   {
      for(size_t i=0; i<it.matrix()->length(curr_dim); i++)
      {
         os << "{";
         mmatrix_output_worker<dataT, _dim, absT, accessorT>(os, it, curr_dim + 1);
         os << "}";
         if(i < it.matrix()->length(curr_dim)-1) os << ",";
      }
   }
   else
   {
      for(size_t i=0; i<it.matrix()->length(_dim-1)-1; i++)
      {
         os << *it << ",";
         ++it;
      }
      os << *it;
      ++it;
   }
}

/// \endcond

///Insert an MMatrixBase into a stream
template<class dataT, size_t _dim, class absT, class accessorT> 
std::ostream& operator << ( std::ostream& os, 
                            MMatrixBase<dataT, _dim, absT, accessorT> & m)
{
   typename MMatrixBase<dataT, _dim, absT, accessorT>::iterator it = m.begin();

   os << "{";
   mmatrix_output_worker<dataT, _dim, absT, accessorT>(os, it, 0);
   os << "}";
   
   return os;
}

///\cond
///Insert an MMatrixBase into a stream, r-value version
template<class dataT, size_t _dim, class absT, class accessorT> 
std::ostream& operator << ( std::ostream& os, 
                            MMatrixBase<dataT, _dim, absT, accessorT> && m)
{
   return operator<<(os, m);
}
///\endcond

} //namespace mx


#endif // __mx_mmatrix_base__



   