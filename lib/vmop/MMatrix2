/** \file MMatrix2
  * \brief Declares and defines the 2-D Matrix specialization of MMatrix
  *
  * \author Jared R. Males (jaredmales@gmail.com)
  *
  */
  
#ifndef __mx_MMatrix2__
#define __mx_MMatrix2__

#include "MMatrixBase"

#include "MMatrix1"

namespace mx
{

template<typename dataT, size_t _dim, typename absT> class MMatrix;
//template<typename dataT, size_t _dim, typename absT> class MMatrixView;

///The Matrix Class: Partial specialization of the MMatrix template class, for 2 dimension2.
/** \ingroup vmop
  * 
  * See the \ref mmatrix2_typedefs where typedefs are provided for the fundamental arithmetic types, 
  * e.g. mx::Vectord is a vector of doubles. 
  *
  * \tparam dataT is the data type being stored
  * \tparam absT is the type of the absolute value of dataT (default is absT = dataT)
  */
template<typename dataT, typename absT> 
class MMatrix<dataT, 2, absT> : public MMatrixBase<dataT, 2, absT,accessor_vector<2> >
{

public:
      
   /** @name Construction and Destruction
     * The standard MMatrixBase constructors are provided in addition to those documented here.
     */
   //@{
   
   /** \cond */
   //These are documented in MMatrixBase
   
   ///Default constructor. Initializes the members but does not allocate storage.
   MMatrix();

   ///Construct and allocate the _data array with the size of each dimension specified in an array of length 2.
   /** 
     * \param sizes is an array of length 2 specifying the size of each dimension
     */
   explicit MMatrix(const size_t *sizes);

   /** \endcond */
   
   ///Construct and allocate the data array with the specified size.
   /** 
     * \param size0 is the desired number of rows
     * \param size1 is the deisred number of columns
     */  
   MMatrix( const size_t size0, 
            const size_t size1);
      
   /** \cond */
   
   ///Construct and allocate the data array with the specified size.
   /** 
     * \param size0 is the desired number of rows
     * \param size1 is the deisred number of columns
     */  
   MMatrix( const int size0, 
            const int size1);
   
   /** \endcond */
   
   ///Construction from initializer list.
   /** Example:
     * \code
     * MMatrix<double, 2> m = {{0.2, 0.5, 0.7, 0.8},{1.2, 1.5, 1.7, 1.8}};
     * \endcode
     *
     * \param init is the initializer list
     */
   MMatrix(std::initializer_list<std::initializer_list<dataT> > init);
      
   /** \cond */
   
   ///Copy constructor.
   /**
     * \param m is the matrix to copy
     */
   template<class mmatrixT>
   MMatrix(const mmatrixT & m );

   
   ///Move constructor.
   /** A shallow copy (re-point) is performed, and then ownership is taken of the storage array.
     *
     * \param m is an r-value reference to a matrix to copy.
     */
   template<class mmatrixT>
   MMatrix(mmatrixT && m);

 
   ///Destructor.  If owned, the _data storage is freed.
   virtual ~MMatrix();

   //@}

   /** \endcond */
   
   /** @name Re-sizing
     */
   //@{
         
   ///Resize the storage array
   /** If size does not change, and the block is already owned, this does nothing.
     *
     * \param size0
     * \param size1
     */
   void allocate( const size_t size0, 
                  const size_t size1 );
   
    /** \cond */
    
   ///Resize the storage array
   /** If size does not change, and the block is already owned, this does nothing.
     * This is here to manage template base class lookup while keep virtual-ness, so it 
     * just calls MMatrixBase::resize(size_t *).
     *
     * \param sizes is an array of length 1
     */
   void allocate(const size_t * sizes);
   
   /** \endcond */
   //@}
      
   /** @name Assignment
     */  
   //@{
  
   /** \cond */
   MMatrix  & operator=(const MMatrix & m);
   MMatrix & operator=(MMatrix && m);
   
   ///Assignment operator
   /** This must be redefined for proper template resolution.
     *
     * \param m the matrix to assign from
     *
     * \returns a reference to *this
     */
   template<class argT>
   MMatrix  & operator=(const argT & m);
      
   ///r-value assignment operator
   /** This must be redefined for proper template resolution.
     *
     * \param m the matrix to assign from
     *
     * \returns a reference to *this
     */
   template<class argT>
   MMatrix & operator=(argT && m);
  
   /** \endcond */
   
   ///Initializer list assignment
   /** 
     * \param init a nested initializer list of dataTs.
     *
     * \retval a reference to *this.
     */
   virtual MMatrix<dataT, 2, absT> & assign_ilist(std::initializer_list<std::initializer_list<dataT> > & init);
  
   ///Initializer list assignment operator
   /** Assign from a nested initializer list. Example:
     * \code
     * MMatrix<double, 2> mat  = {{0.2, 0.5, 0.7, 0.8},{0.3, 0.6, 0.8, 0.9}};
     * \endcode
     * 
     * This calls assign_ilist, where the work is done.
     * 
     * \param init is an initializer list of dataTs.
     *
     * \returns a reference to *this.
     */
   virtual MMatrix<dataT, 2, absT> & operator=(std::initializer_list<std::initializer_list<dataT> > init);
   
   
   
   //@}
  

   /** @name Row Access Operators
     */
   //@{
  
   /// Get a single row of the matrix.
   /** This returns a single row.
     *
     * \param d is the row index.
     *
     * \returns a vector view, of type MMatrixView<dataT, 1, absT>
     */
   virtual MMatrixView<dataT, 1, absT, accessor_vector<1> > get_row( const size_t d );
   
   /// Get a single row of the matrix.
   /** This calls get_row, returning a single row.
     *
     * \param d is the row index.  Can also be mx::BEG or mx::LAST.
     *
     * \returns a vector view, of type MMatrixView<dataT, 1, absT>
     */
   MMatrixView<dataT, 1, absT,accessor_vector<1> > operator()( const size_t d );
      
    /** \cond */
   //Additional overloads
   MMatrixView<dataT, 1, absT,accessor_vector<1> > operator()(const MMatrixBound_BEG b);
   
   MMatrixView<dataT, 1, absT, accessor_vector<1> > operator()(const MMatrixBound_LAST l);

   /** \endcond */
   
   //@}
   
   /** @name Slice Operators
     * The Slice operators return a submatrix.
     * A slice by itself can not be used. These operators must always be followed by another () pair.
     */
  //@{

   /// Get a slice (submatrix).
   /** This returns a slice from row \p start to row \p end - 1, in steps
     * of size \p stride
     *
     * \param start is the first row
     * \param stride is the stepsize
     * \param end is one past the last row
     *
     * \returns an MMatrixSlice of the matrix
     */
//   virtual MMatrixSlice<1, dataT, 2, absT, accessor_stride<2> > get_slice( const size_t start, 
                             //                         const size_t stride, 
                             //                         const size_t end );
  
   /// Get a slice (submatrix).
   /** This returns a slice from row \p start to row \p end - 1, in steps
     * of size \p stride
     *
     * \param start is the first row
     * \param stride is the stepsize
     * \param end is one past the last row
     *
     * \returns an MMatrixSlice of the matrix
     */
//  virtual MMatrixSlice<1, dataT, 2, absT, accessor_stride<2> > operator()( const size_t start, 
                               //                       const size_t stride, 
                               //                       const size_t end );
  /** \cond */
   //These overrides implement BEG and END boundaries, and stride=1 versions.
  
  /// Get a slice (submatrix) from the first row to the last row.
  /** This returns a slice from the first row to the last row, in steps
    * of size \p stride
    *
    * \param start is an object of type MMatrixBound_BEG, which just means "first row"
    * \param stride is the step size
    * \param end is an object of type MMatrixBound_END, which just means "one past the last row"
    *
    * \returns an MMatrixSlice of the matrix
    */
//  virtual MMatrixSlice<1, dataT, 2, absT, accessor_stride<2> > operator()( const MMatrixBound_BEG start, 
                                 //                     const size_t stride, 
                                 //                     const MMatrixBound_END end );
                                          
  /// Get a slice (submatrix) up to and including the last row.
  /** This returns a slice from row \p start to one past the last row, in steps
    * of size \p stride
    *
    * \param start is the first row
    * \param stride is the stepsize
    * \param end is an object of type MMatrixBound_END, which just means "one past the last row"
    *
    * \returns an MMatrixSlice of the matrix
    */
//  virtual MMatrixSlice<1, dataT, 2, absT, accessor_stride<2> > operator()( const size_t start, 
                                  //                    const size_t stride, 
                                  //                    const MMatrixBound_END end );
                                          
  /// Get a slice (submatrix) starting from the first row.
  /** This returns a slice from the first row to row \p end - 1, in steps
    * of size \p stride
    *
    * \param start is an object of type MMatrixBound_BEG, which just means "first row"
    * \param stride is the stepsize
    * \param end is one past the last row
    *
    * \returns an MMatrixSlice of the matrix
    */
//  virtual MMatrixSlice<1, dataT, 2, absT, accessor_stride<2> > operator()( const MMatrixBound_BEG start, 
                                   //                   const size_t stride, 
                                   //                   const size_t end );
                                          
  /// Get a slice (submatrix) with stride = 1.
  /** This returns a slice from row \p start to row \p end - 1, in steps
    * of size 1.
    *
    * \param start is the first row
    * \param end is one past the last row
    *
    * \returns an MMatrixSlice of the matrix
    */
//  virtual MMatrixSlice<1, dataT, 2, absT, accessor_vector<1> > operator()( const size_t start, 
                                  //                    const size_t end );
                                          
  /// Get a slice (submatrix) from the first row to the last row with stride=1.
  /** This returns a slice from the first row to the last row, in steps
    * of size 1.
    *
    * \param start is an object of type MMatrixBound_BEG, which just means "first row"
    * \param end is an object of type MMatrixBound_END, which just means "one past the last row"
    *
    * \returns an MMatrixSlice of the matrix
    */
//  virtual MMatrixSlice<1, dataT, 2, absT, accessor_vector<1> > operator()( const MMatrixBound_BEG start, 
                                    //                  const MMatrixBound_END end );
                                          
  /// Get a slice (submatrix) up to and including the last row with stride=1.
  /** This returns a slice from row \p start to one past the last row, in steps
    * of size 1.
    *
    * \param start is the first row
    * \param end is an object of type MMatrixBound_END, which just means "one past the last row"
    *
    * \returns an MMatrixSlice of the matrix
    */
//  virtual MMatrixSlice<1, dataT, 2, absT, accessor_vector<1> > operator()( const size_t start,  
                                      //                const MMatrixBound_END end );
                                          
  /// Get a slice (submatrix) starting from the first row.
  /** This returns a slice from the first row to row \p end - 1, in steps
    * of size 1.
    *
    * \param start is an object of type MMatrixBound_BEG, which just means "first row"
    * \param end is one past the last row
    *
    * \returns an MMatrixSlice of the matrix
    */
//  virtual MMatrixSlice<1, dataT, 2, absT, accessor_vector<1> > operator()( const MMatrixBound_BEG start, 
                                        //              const size_t end );
      
   /** \endcond */
   //@}

};

template<typename dataT, typename absT> 
MMatrix<dataT, 2, absT>::MMatrix() : MMatrixBase<dataT, 2, absT, accessor_vector<2> >()
{  
}

template<typename dataT, typename absT>
MMatrix<dataT, 2, absT>::MMatrix(const size_t * sizes) : MMatrixBase<dataT, 2, absT, accessor_vector<2> >(sizes)
{
}

template<typename dataT, typename absT> 
MMatrix<dataT, 2, absT>::MMatrix( const size_t size0, 
                                  const size_t size1) 
{
   size_t sizes[2];
   
   sizes[0] = size0;
   sizes[1] = size1;
   
   allocate(sizes);
}

template<typename dataT, typename absT> 
MMatrix<dataT, 2, absT>::MMatrix( const int size0, 
                                  const int size1) 
{
   size_t sizes[2];
   
   sizes[0] = size0;
   sizes[1] = size1;
   
   allocate(sizes);
}

template<typename dataT, typename absT> 
MMatrix<dataT, 2, absT>::MMatrix(std::initializer_list<std::initializer_list<dataT> > init)
{ 
   assign_ilist(init);  
}

template<typename dataT, typename absT> 
template<class mmatrixT>
MMatrix<dataT, 2, absT>::MMatrix(const mmatrixT & m) : MMatrixBase<dataT, 2, absT, accessor_vector<2> >(m)
{
}


template<typename dataT, typename absT> 
template<class mmatrixT>
MMatrix<dataT, 2, absT>::MMatrix(mmatrixT && m) : MMatrixBase<dataT, 2, absT, accessor_vector<2> >(m)
{
}


template<typename dataT, typename absT> 
MMatrix<dataT, 2, absT>::~MMatrix()  
{
}

template<typename dataT, typename absT> 
void MMatrix<dataT, 2, absT>::allocate( const size_t size0, 
                                        const size_t size1 )
{
   size_t sizes[2];
   sizes[0] = size0;
   sizes[1] = size1;
   
   allocate(sizes);   
}

template<typename dataT, typename absT> 
void MMatrix<dataT, 2, absT>::allocate(const size_t * sizes)
{
   MMatrixBase<dataT, 2, absT, accessor_vector<2> >::allocate(sizes);  
}

template<typename dataT, typename absT> 
MMatrix<dataT, 2, absT> & MMatrix<dataT, 2, absT>::operator=(const MMatrix & arg)
{ 
   MX_MM_DEBUG_TRACE("MMatrix2::operator=(&)");
   MMatrixBase<dataT, 2, absT, accessor_vector<2> >::copy(arg); 
   
   return *this;
}

template<typename dataT, typename absT> 
MMatrix<dataT, 2, absT> & MMatrix<dataT, 2, absT>::operator=(MMatrix && arg)
{ 
   MX_MM_DEBUG_TRACE("MMatrix2::operator=(&&)");
   MMatrixBase<dataT, 2, absT, accessor_vector<2> >::assign_move(arg);
   
   return *this;
}
     
template<typename dataT, typename absT> 
MMatrix<dataT, 2, absT> & MMatrix<dataT, 2, absT>::assign_ilist(std::initializer_list<std::initializer_list<dataT> > & init)
{
   size_t rows = init.size();
   
   typename std::initializer_list<std::initializer_list<dataT> >::iterator it;
   
   it = init.begin();
   size_t cols = (*it).size();
   it++;
   while(it != init.end())
   {
      if((*it).size() > cols) cols = (*it).size();
      it++;
   }
   
   allocate(rows, cols);
   
   it = init.begin();
   typename std::initializer_list<dataT>::iterator it2;
   
   int i, j;
   
   for(i=0;i<rows; i++)
   {
      it2 = it->begin();
      for(j=0;j<cols; j++)
      {
         if(j >= (*it).size())
         {
            size_t d[2];
            d[0] = i;
            d[1] = j;
            this->set(d, 0);
         }
         else
         {
            size_t d[2];
            d[0] = i;
            d[1] = j;
            set(d, *it2);
            ++it2;
         }
      }
      ++it;
   }
   
   
   return *this;
}//assign_ilist(std::initializer_list<std::initializer_list<dataT> > &)


template<typename dataT, typename absT> 
MMatrix<dataT, 2, absT> & MMatrix<dataT, 2, absT>::operator=(std::initializer_list<std::initializer_list<dataT> > init)
{ 
   std::cout << "operator=init\n";
   return assign_ilist(init); 
}


template<typename dataT, typename absT> 
inline MMatrixView<dataT, 1, absT, accessor_vector<1> > MMatrix<dataT, 2, absT>::get_row(const size_t d)
{ 
   size_t start = d*this->size(1);
   size_t end = (d+1)*this->size(1);
   
   MMatrixView<dataT, 1, absT, accessor_vector<1> > vview(*this, &start, &end);
   return vview; 
}

template<typename dataT, typename absT> 
inline MMatrixView<dataT, 1, absT, accessor_vector<1> > MMatrix<dataT, 2, absT>::operator()(const size_t d)
{ 
   return get_row(d); 
}
   
template<typename dataT, typename absT> 
inline MMatrixView<dataT, 1, absT, accessor_vector<1> > MMatrix<dataT, 2, absT>::operator()(const MMatrixBound_BEG b)
{ 
   return get_row(0); 
}

template<typename dataT, typename absT> 
inline MMatrixView<dataT, 1, absT, accessor_vector<1> > MMatrix<dataT, 2, absT>::operator()(const MMatrixBound_LAST l)
{ 
   return get_row(this->_length[0]-1); 
}   

// template<typename dataT, typename absT> 
// inline MMatrixSlice<1, dataT, 2, absT> MMatrix<dataT, 2, absT>::get_slice( const size_t start, 
//                                                                            const size_t stride, 
//                                                                            const size_t end )
// {
//    MMatrixSlice<1, dataT, 2, absT> mslice(this, start, stride, end);
// 
//    return mslice;
// }
// 
//    
// template<typename dataT, typename absT> 
// MMatrixSlice<1, dataT, 2, absT> MMatrix<dataT, 2, absT>::operator()( size_t start, 
//                                                                      size_t stride, 
//                                                                      size_t end )
// {
//    return get_slice(start, stride, end);
// }
// 
// template<typename dataT, typename absT> 
// MMatrixSlice<1, dataT, 2, absT> MMatrix<dataT, 2, absT>::operator()( mx::MMatrixBound_BEG start, 
//                                                                      size_t stride, 
//                                                                      mx::MMatrixBound_END end )
// {
//    return get_slice(0, stride, this->_length[0]);
// }
// 
// template<typename dataT, typename absT> 
// MMatrixSlice<1, dataT, 2, absT> MMatrix<dataT, 2, absT>::operator()( size_t start, 
//                                                                      size_t stride, 
//                                                                      mx::MMatrixBound_END end )
// {
//    return get_slice(start, stride, this->_length[0]);
// }
// 
// template<typename dataT, typename absT> 
// MMatrixSlice<1, dataT, 2, absT> MMatrix<dataT, 2, absT>::operator()( mx::MMatrixBound_BEG start, 
//                                                                      size_t stride, 
//                                                                      size_t end )
// {
//    return get_slice(0, stride, end);
// }
// 
// template<typename dataT, typename absT> 
// MMatrixSlice<1, dataT, 2, absT> MMatrix<dataT, 2, absT>::operator()( size_t start, 
//                                                                      size_t end )
// {
//    return get_slice(start, 1, end);
// }
// 
// template<typename dataT, typename absT> 
// MMatrixSlice<1, dataT, 2, absT> MMatrix<dataT, 2, absT>::operator()( mx::MMatrixBound_BEG start,  
//                                                                      mx::MMatrixBound_END end )
// {
//    return get_slice(0, 1, this->_length[0]);
// }
// 
// template<typename dataT, typename absT> 
// MMatrixSlice<1, dataT, 2, absT> MMatrix<dataT, 2, absT>::operator()( size_t start, 
//                                                                      mx::MMatrixBound_END end )
// {
//    return get_slice(start, 1, this->_length[0]);
// }
// 
// template<typename dataT, typename absT> 
// MMatrixSlice<1, dataT, 2, absT> MMatrix<dataT, 2, absT>::operator()( mx::MMatrixBound_BEG start, 
//                                                                      size_t end )
// {
//    return get_slice(0, 1, end);
// }



/** \defgroup mmatrix2_typedefs Matrix Typedef Declarations
  * \ingroup vmop
  * typedefs for for MMatrix<dataT, 2, absT>
  */
//@{
typedef MMatrix<bool, 2> Matrixb;///<A matrix of bools.
typedef MMatrix<char, 2> Matrixc;///<A matrix of chars.
typedef MMatrix<unsigned char, 2> Matrixuc; ///<A matrix of unsigned chars.
typedef MMatrix<short, 2> Matrixs; ///<A matrix of short integers.
typedef MMatrix<unsigned short, 2> Matrixus; ///<A matrix of unsigned shorts.
typedef MMatrix<int, 2> Matrixi; ///<A matrix of integers.
typedef MMatrix<unsigned int, 2> Matrixui; ///<A matrix of unsigned integers.
typedef MMatrix<unsigned, 2> Matrixu; ///<A matrix of unsigned integers (same as Vectorui, matter of taste).
typedef MMatrix<long, 2> Matrixl; ///<A matrix of long integers.
typedef MMatrix<unsigned long, 2> Matrixul; ///<A matrix of unsigned longs.
typedef MMatrix<long long, 2> Matrixll; ///<A matrix of long long integers
typedef MMatrix<unsigned long long, 2> Matrixull; ///<A matrix of unsigned long long ints.
typedef MMatrix<size_t, 2> Matrixsz; ///<A matrix of size_t.  Used to return and pass indices.
typedef MMatrix<double, 2> Matrixd; ///<A matrix of doubles.
typedef MMatrix<float, 2> Matrixf; ///<A matrix of floats.
typedef MMatrix<long double, 2> Matrixld; ///<A matrix of long doubles.
typedef MMatrix<std::complex<double>, 2, double> Matrixcd; ///<A matrix of complex doubles
typedef MMatrix<std::complex<float>, 2, float> Matrixcf; ///<A matrix of complex floats
typedef MMatrix<std::complex<long double>, 2, long double> Matrixcld; ///<A matrix of complex doubles




//@}

}; //mx

//#include "MMatrixView2"

#endif //__mx_MMatrix1__



      
      