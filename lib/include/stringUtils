/** \file stringUtils
  * \brief utilities for working with strings
  * 
  * \author Jared R. Males (jaredmales@gmail.com)
  * 
  * \ingroup stringutils
  *
  */

#include <string>
#include <sstream>

#ifndef __stringUtils__
#define __stringUtils__



/// The mxlib c++ namespace
namespace mx
{

/** \addtogroup stringutils
  * @{
  */

///Convert a numerical value to a string
/** \details The default version uses the stream library to convert. 
  *
  * Example:
  * \code
  * double d = 2.898434;
  * std::string str;
  * str = convertToString(d);  //note that you will not normally need to specify <typeT>
  * \endcode
  *
  * \tparam typeT is the type of value to convert
  * 
  * \param value the value of type typeT to be converted
  * 
  * \returns a string representation of value
  */
template<typename typeT> 
std::string convertToString(const typeT & value)
{
   std::ostringstream convert;
   
   convert << value;
   
   return convert.str();
}

/// Specialization of convertToString to avoid converting a string to a string
template<> 
inline std::string convertToString<std::string>(const std::string & value)
{
   return value;
}


/// Convert a string to a numerical value.
/** The default version attempts to do the conversion with a simple c style cast.  The various template specializations
  * handle conversions to the basic types.
  * 
  * Example:
  * \code
  * std::string str = "2.34567";
  * double d;
  * d = convertFromString<double>(str);
  * \endcode
  * 
  * \tparam typeT is the type of the numerical value desired
  * 
  * \param str is the std::string object to convert.
  * 
  * \returns the converted numerical value.
  */
template<typename typeT> 
typeT convertFromString(const std::string & str)
{
   //If no specialization exists, we try to cast
   return (typeT) str;
}

/// Template specialization of convertFromString for char
template<> inline 
char convertFromString<char>(const std::string & str)
{
   return (char) atoi(str.c_str());
}

/// Template specialization of convertFromString for unsigned char
template<> inline 
unsigned char convertFromString<unsigned char>(const std::string & str)
{
   return (unsigned char) atoi(str.c_str());
}

/// Template specialization of convertFromString for short
template<> inline 
short convertFromString<short>(const std::string & str)
{
   return (short) atoi(str.c_str());
}

/// Template specialization of convertFromString for unsigned short
template<> inline 
unsigned short convertFromString<unsigned short>(const std::string & str)
{
   return (unsigned short) atoi(str.c_str());
}

/// Template specialization of convertFromString for int
template<> inline 
int convertFromString<int>(const std::string & str)
{
   return atoi(str.c_str());
}

/// Template specialization of convertFromString for unsigned int
template<> inline 
unsigned int convertFromString<unsigned int>(const std::string & str)
{
   return (unsigned int) atoi(str.c_str());
}

/// Template specialization of convertFromString for long
template<> inline 
long convertFromString<long>(const std::string & str)
{
   return strtol(str.c_str(), 0, 0);
}

/// Template specialization of convertFromString for unsigned long
template<> inline 
unsigned long convertFromString<unsigned long>(const std::string & str)
{
   return strtoul(str.c_str(), 0, 0);
}

/// Template specialization of convertFromString for long long
template<> inline 
long long convertFromString<long long>(const std::string & str)
{
   return strtoll(str.c_str(), 0, 0);
}

/// Template specialization of convertFromString for unsigned long long
template<> inline 
unsigned long long convertFromString<unsigned long long>(const std::string & str)
{
   return strtoull(str.c_str(), 0, 0);
}

/// Template specialization of convertFromString for float
template<> inline 
float convertFromString<float>(const std::string & str)
{
   return strtof(str.c_str(), 0);
}

/// Template specialization of convertFromString for double
template<> inline 
double convertFromString<double>(const std::string & str)
{
   return strtod(str.c_str(), 0);
}

/// Template specialization of convertFromString for long double
template<> inline 
long double convertFromString<long double>(const std::string & str)
{
   return strtold(str.c_str(), 0);
}


/// @}

} //namespace mx

#endif //__stringUtils__
