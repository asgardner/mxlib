#ifndef __eigenfits__
#define __eigenfits__

#include "fitsio.h"
#include <cstdlib>

/** \ingroup eigenfits
  */

//@{



/* Templatized version of the cfitsio fits_read_pix function
  * \tparam dataT is the data type of the array (and NULL value) to be used.
  */
// // template<typename dataT> int fits_read_pix(fitsfile *fptr, long *fpixel, LONGLONG nelements, dataT *nulval, dataT *array, int *anynul, int *status);
// // 
// // template<> int fits_read_pix<float>(fitsfile *fptr, long *fpixel, LONGLONG nelements, float *nulval, float *array, int *anynul, int *status)
// // {
//    return ::fits_read_pix(fptr, TFLOAT, fpixel, nelements, nulval, array, anynul, status);
// }
// 
// template<> int fits_read_pix<double>(fitsfile *fptr, long *fpixel, LONGLONG nelements, double *nulval, double *array, int *anynul, int *status)
// {
//    return ::fits_read_pix(fptr, TDOUBLE, fpixel, nelements, nulval, array, anynul, status);
// }
// 
// template<> int fits_read_pix<short>(fitsfile *fptr, long *fpixel, LONGLONG nelements, short *nulval, short *array, int *anynul, int *status)
// {
//    return ::fits_read_pix(fptr, TSHORT, fpixel, nelements, nulval, array, anynul, status);
// }

/** Reads the fits file specified into an eigen compatible matrix or array.
  * The minimum eigen API of eigenT requires includes the type Scalar, access to the storage array via data(),
  * and the resize(rows, cols) method.
  * \tparam eigenT the eigen-like type.
  * \param file_name is the path to the fits file.
  * \returns the populated array.
  */
template<class eigenT> eigenT eigen_readfits(std::string file_name, typename eigenT::Scalar * nulval = NULL, int * anynul = NULL)
{
   fitsfile * fptr;
   int fstatus = 0;
   int naxis;
   long * naxes;
   size_t * dims;

   eigenT imMat;

   fits_open_file(&fptr, file_name.c_str(), READONLY, &fstatus);
   if (fstatus)
   {
      fprintf(stderr, "Error opening file: %s.\n", file_name.c_str());
      fits_report_error(stderr, fstatus); // print any error message 
      return imMat;
   }

   fits_get_img_dim(fptr, &naxis, &fstatus);
   if (fstatus)
   {
      fprintf(stderr, "Error getting number of axes in file: %s.\n", file_name.c_str());
      fits_report_error(stderr, fstatus);
      fits_close_file(fptr, &fstatus);
      return imMat;
   }

   std::cout << naxis << std::endl;
   
   naxes = new long[naxis];

   fits_get_img_size(fptr, naxis, naxes, &fstatus);
   if (fstatus)
   {
      fprintf(stderr, "Error getting image dimensions in file: %s.\n", file_name.c_str());
      fits_report_error(stderr, fstatus); // print any error message 
      delete[] naxes;
      fits_close_file(fptr, &fstatus);
      return imMat;
   }

   std::cout << naxes[0] << std::endl;
   std::cout << naxes[1] << std::endl;
   
   dims = new size_t[2];
   
   dims[0] = (size_t) naxes[0];
   dims[1] = (size_t) naxes[1];
   
   //for(int i=2;i<naxis;i++) dims[i] = (size_t) naxes[i];


   imMat.resize(dims[0], dims[1]);

   long long nelements =1;
   long *fpix = new long[naxis];

   for(int i=0;i<naxis; i++)
   {
      fpix[i] = 1;
      nelements *= naxes[i];
   }

   //fits_read_pix<typename eigenT::Scalar>(fptr, fpix, nelements, nulval, imMat.data(), 0, &fstatus);
   fits_read_pix(fptr, getFitsType<typename eigenT::Scalar>(), fpix, nelements, (void *) nulval, 
                                     (void *) imMat.data(), anynul, &fstatus);
   
   if (fstatus && fstatus != 107)
   {
      fprintf(stderr, "Error in reading data from file %s.\n", file_name.c_str());
      fits_report_error(stderr, fstatus);
      delete[] naxes;
      delete[] fpix;
      delete[] dims;
      fits_close_file(fptr, &fstatus);
      return imMat;
   }

   delete[] naxes;
   delete[] fpix;
   delete[] dims;
   fits_close_file(fptr, &fstatus);
   return imMat;
}






//@}

#endif //__eigenfits__

