#ifndef __mx_imaging__
#define __mx_imaging__

namespace mx
{

#include <cmath>


/// Fill in a vmop 2D matrix with a circular pupil mask.
/** \ingroup vmop_tools
  * \ingroup imaging
  *
  * \param m is the allocated MMatrix
  * \param eps [optional] is the central obscuration.  0-1, default is 0.
  * \param rad [optional] is the desired radius. if 0 the maximum radius is used.
  */  
template<class vmopMatrix> 
void circular_pupil( vmopMatrix & m, 
                     typename vmopMatrix::data_type eps=0, 
                     typename vmopMatrix::data_type rad=0 
                   )
{
   size_t l0 = m.length(0);
   size_t l1 = m.length(1);
   
   typename vmopMatrix::data_type r;
   typename vmopMatrix::data_type xc = 0.5*(l0-1);
   typename vmopMatrix::data_type yc = 0.5*(l1-1);
   
   if(rad == 0) rad = 0.5*std::min(l0-1, l1-1);
   
   for(size_t i=0; i < l0; i++)
   {
      for(size_t j=0; j < l1; j++)
      {
         r = std::sqrt( std::pow(i-xc, 2) + std::pow(j-yc, 2) );
         
         if(r <= rad+0.5 && r >= eps*rad) m(i)(j) = 1;
         else m(i)(j) = 0;
      }
   }
}


/// Create a vmop 2D matrix and fill it in with a circular pupil mask.
/** \ingroup vmop_tools
  * \ingroup imaging
  *
  * \param sz0 is the size of the matrix in dimension 0
  * \param sz1 is the size of the matrix in dimension 1
  * \param eps [optional] is the central obscuration.  0-1, default is 0.
  * \param rad [optional] is the desired radius. if 0 the maximum radius is used.
  */  
template<class vmopMatrix> 
vmopMatrix circular_pupil( size_t sz0,
                     size_t sz1,
                     typename vmopMatrix::data_type eps=0, 
                     typename vmopMatrix::data_type rad=0 
                   )
{
   vmopMatrix m(sz0, sz1);
   
   circular_pupil(m, eps, rad);
   
   return m;
}


} //namespace mx

#endif //__mx_imaging__

