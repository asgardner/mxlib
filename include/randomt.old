//mxrandomt, vers. 0.0.51, 04 Jul 2006
//by Jared R. Males (http://jaredmales.com)

//license

#ifndef __randomT__
#define __randomT__


#include <vector>
//#include <iostream>
//#include <fstream>
#include <cmath>
#include <climits>


/************************************************************/
/* Preprocessing Diagnostics                                */
/* Testing to use smallest type available for word size     */
/************************************************************/

//Not all c++ systems fully support C99 (including gnu g++)
//(nor do they have to)
//This corrects for lack of ULLONG macros
//Compiling in g++ with -pedantic will fail on long long

#ifndef LLONG_MAX
 #define LLONG_MAX   9223372036854775807LL
#endif
#ifndef LLONG_MIN
 #define LLONG_MIN   (-9223372036854775807LL - 1LL)
#endif
#ifndef ULLONG_MAX
 #define ULLONG_MAX 18446744073709551615ULL
#endif

#ifndef MX_WORD_SIZE
   #define MX_WORD_SIZE 32
#endif //MX_WORD_SIZE

//test for size of int.  if int isn't long enough for the word, try long.
#if MX_WORD_SIZE == 64
   #if UINT_MAX >= 18446744073709551615U
      #define RANDOMT_WORD   unsigned int
      #define RANDOMT_WORDMAX 18446744073709551615U
      #define RANDOMT_SIGNED int
   #elif ULONG_MAX >= 18446744073709551615UL
      #define RANDOMT_WORD   unsigned long int
      #define RANDOMT_WORDMAX 18446744073709551615UL
      #define RANDOMT_SIGNED long int
   #elif ULLONG_MAX >= 18446744073709551615ULL
      //long long is not supported by c++98
      #define RANDOMT_WORD   unsigned long long int
      #define RANDOMT_WORDMAX 18446744073709551615ULL
      #define RANDOMT_SIGNED long long int
   #else
      #error MX::randomT: not enough bits, can't handle 64 bit word size.'
   #endif
#else
   #if UINT_MAX >= 4294967295
      #define RANDOMT_WORD   unsigned int
      #define RANDOMT_WORDMAX 4294967295U
      #define RANDOMT_SIGNED int
   #elif ULONG_MAX >= 4294967295
      #define RANDOMT_WORD   unsigned long int
      #define RANDOMT_WORDMAX 4294967295UL
      #define RANDOMT_SIGNED long int
   #else
      #error MX::randomT: not enough bits, can't handle 32 bit word size.'
   #endif
#endif

#if MX_WORD_SIZE == 64
   #define MT_TYPE unsigned long long
#else
   #define MT_TYPE unsigned long
#endif

namespace mx
{

///Generates pseudo-random numbers from various (specifiable) generators.
/** Functions as a variable of type typeT, that is randomT<typeT, floatT> r can be
  * used in an expression such as typeT d = r.  This assigns the next
  * number in the sequence to d.  The next call to d = r returns a new
  * pseudo random number.  It is also possible to specify what distribution 
  * the numbers are chosen from, such as uniform, normal, etc
  * The default distribution is "basic", which is whatever is returned by the
  * generator.
  * Meets the requirements for Assignable of ISO 14882, since assignment 
  * returns a random value of type randomT<typeT, floatT>. //
  * typeT  must be Assignable, have the arithmetic (+-/*) operators defined,
  * and have cast operations for unsigned integer types defined.
  * floatT is a floating point type used for calculations.  defaults to double.
  *
  * The following pseudo-random number generators are available:
  * ISO_PORTABLE - uses the example generator of ISO+IEC+9899-1999 sect.7.20.1.1.5 (the C standard).
  * ISO_PORTABLE_ULONG - uses the same constants, but does the full long modulus.
  * MIN_STD - constants due to M, X, and X as discussed in Numerical Recipes.
  * PARK_AND_MILLER1 - as discussed in NR
  * PARK_AND_MILLER2 - as discussed in NR
  * MERSENNE_TWISTER - Generator due to  M. Matsumoto and T. Nishimura
  * 
  * The Following distributions are available:
  * BASIC - returns the unsigned long int directly from the generator.
  * UNIFORM_DEVIATE - returns a value r such that (params[0] < r <= params[1])
  * STD_NORMAL_DEVIATE - returns r normally distributed with mean 0 and stddev 1
  * NORMAL_DEVIATE - returns a value r such that (params[0] < r <= params[1]) based on the
  * normal (Gaussian) distribution with mean params[2] and std. deviation params[3].
  * std deviation is used instead of variance to avoid calling sqrt().
  */
template <class typeT, class floatT = double> class randomT
{
   public:
      //Constructors
      randomT(); //defaults to MERSENNE_TWISTER with BASIC distribution

      randomT(RANDOMT_WORD); //sets seed, uses BASIC distribution
      randomT(typeT, typeT); //sets distribution to UNIFORM_DEVIATE, with specified range.
      randomT(RANDOMT_WORD, typeT, typeT); //seed and range.  Initializes to UNIFORM_DEVIATE
      randomT(RANDOMT_WORD, unsigned int, typeT, typeT);  //seed, generator,and range. initializes
                                                //to uniform deviate.
                                                //The constructors that initialize to uniform
                                                //deviate are provided because this is the most 
                                                //common use likely for this class.

      enum generators {ISO_PORTABLE, ISO_PORTABLE_ULONG, MIN_STD, PARK_AND_MILLER1, PARK_AND_MILLER2,
                         MERSENNE_TWISTER, GENERATOR_MAX};   //which generator to use.
                                                   //GENERATOR_MAX is for bounds check.

      enum distributions {BASIC, STD_UNIFORM_DEVIATE, UNIFORM_DEVIATE, STD_NORMAL_DEVIATE, NORMAL_DEVIATE, NORMAL_DEVIATE_SQREJECT, DEXP_DEVIATE, DISTRIBUTION_MAX}; //DISTRIBUTION_max is for bounds check.


   protected:
      bool is_floatT;
      int test_floatT();

      unsigned int generator; //specifies which generator to use
      unsigned int distribution; //specifies which distribution to use

      std::vector<typeT> params; //parameters for the chosen distribution.
      /* For UNIFORM_DEVIATE params[0] is min, params[1] is max.*/
      /* For NORMAL_DEVIATE params[0] is min, params[1] is max, params[2] is mean,
         and params[3] is std deviation*/

      RANDOMT_WORD seed;
      RANDOMT_WORD max_random; //max. possible (long unsigned int) number from the generator.
      RANDOMT_WORD last_random; //last number returned by the generator.

      /*variables used for rejection method*/
      typeT rand1;
      typeT rand2;
      unsigned int pass;

      //Mersenne Twister wrapper functions.
      //These functions just call the corresponding functions from mt19937int_mx.cpp
      MT_TYPE * mt;
      int mti;

      int mt_init_genrand(RANDOMT_WORD);
      void init_genrand(unsigned long s);

      int get_mt(MT_TYPE ** omt) { *omt = mt; return 0; }

      int set_mti(int nmti) { mti = nmti; return 0;}
      int get_mti(int *nmti) { *nmti = mti; return 0;}

      int mt_genrand(RANDOMT_WORD *);
      unsigned long genrand_int();

   public:
      int set_seed(RANDOMT_WORD, typeT *); //sets the seed, and gets next_value().
                                           //will not set to 0, sets to 1 in that case
                                           //returns 1 if this happens.

      int mt_init_by_array(MT_TYPE *, int); //public for testing
      void init_by_array(unsigned long * init_key, int key_length);

      int get_seed(RANDOMT_WORD *);  //gets the current value of the seed.
                                     //this is a constant non-random value.

      int set_generator(unsigned int); //Picks which generator to use
                                       //assigns max_random appropriately.
                                       //if unknown generator defaults to mt and returns 1

      int get_generator(unsigned int *); //gets the current generator
      int get_max_random(RANDOMT_WORD *);//returns the max. value possible based on distribution

      int set_distribution(unsigned int); //sets which distribution to use
      int get_distribution(unsigned int *); //Returns the current distribution

      int set_params(std::vector<typeT> *); //set the distribution parameters
                                      //need to make a variadic version.
      int get_params(std::vector<typeT> *);//get the params vector

      int next_random(RANDOMT_WORD *); //gets the next random number from the generator

      int get_last_random(RANDOMT_WORD *);//gets the current value of the generator
                                     //does not increment.

      int get_std_uniform_deviate(typeT *);//set 0 <= r < 1, increments generator

      int get_std_normal_deviate(typeT *);//set r to deviate with mean 0, stddev 1, increments

      int get_normal_deviate(typeT *);//r normal deviate with mean params[0], sd params[1]

      int get_normal_deviate_sqreject(typeT *);//set r to deviate with mean m
                                                             //stddev s using rejection method
                                                             //in a square. increments.
      int get_dexp_deviate(typeT *);

      int next_value(typeT *); //returns the next value from the distribution

      int assign(randomT<typeT, floatT>); //asssignment
      randomT<typeT, floatT> operator = (randomT<typeT, floatT>);

      typeT operator = (RANDOMT_WORD);  //sets the seed.

      operator typeT();  //reference

}; //template <class typeT, class floatT> class randomT

template <class typeT, class floatT> randomT<typeT, floatT>::randomT()
{
   #ifdef RANDOMT_USE_MXLIB
      set_BASE_VALS("randomT", RANDOMT_VERSION, RANDOMT_DATE);
   #endif

   test_floatT();
   mt = 0;
   set_generator(MERSENNE_TWISTER);
   set_distribution(BASIC); //default must be BASIC since any
                           //other choice might fail for non-float typeT
   set_seed(1,0);

}//randomT()

template <class typeT, class floatT> randomT<typeT, floatT>::randomT(RANDOMT_WORD sd)
{
   #ifdef RANDOMT_USE_MXLIB
      set_BASE_VALS("randomT", RANDOMT_VERSION, RANDOMT_DATE);
   #endif

   test_floatT();
   mt = 0;
   set_generator(MERSENNE_TWISTER);
   set_distribution(BASIC);
   set_seed(sd, 0);

}//randomT(RANDOMT_WORD)

template <class typeT, class floatT> randomT<typeT, floatT>::randomT(typeT rmin, typeT rmax)
{
   #ifdef RANDOMT_USE_MXLIB
      set_BASE_VALS("randomT", RANDOMT_VERSION, RANDOMT_DATE);
   #endif

   test_floatT();
   mt = 0;
   set_generator(MERSENNE_TWISTER);
   set_distribution(UNIFORM_DEVIATE);
   set_seed(1,0);

   params.resize(2);
   params[0] = rmin;
   params[1] = rmax;

}//randomT(typeT, typeT)

template <class typeT, class floatT> randomT<typeT, floatT>::randomT(RANDOMT_WORD sd, typeT rmin, typeT rmax)
{
   #ifdef RANDOMT_USE_MXLIB
      set_BASE_VALS("randomT", RANDOMT_VERSION, RANDOMT_DATE);
   #endif

   test_floatT();
   mt = 0;
   set_generator(MERSENNE_TWISTER);
   set_distribution(UNIFORM_DEVIATE);
   set_seed(sd);

   params.resize(2);
   params[0] = rmin;
   params[1] = rmax;

}//randomT(RANDOMT_WORD, typeT, typeT)

template <class typeT, class floatT> randomT<typeT, floatT>::randomT(RANDOMT_WORD sd, unsigned int gen,
                                                                   typeT rmin, typeT rmax)
{
   #ifdef RANDOMT_USE_MXLIB
      set_BASE_VALS("randomT", RANDOMT_VERSION, RANDOMT_DATE);
   #endif

   test_floatT();
   mt = 0;
   set_generator(gen); //Call here to allow error checks.
   set_seed(sd);
   set_distribution(UNIFORM_DEVIATE);

   params.resize(2);
   params[0] = rmin;
   params[1] = rmax;

}//randomT(RANDOMT_WORD, unsigned int, typeT, typeT)

template <class typeT, class floatT> int randomT<typeT, floatT>::test_floatT()
{
   typeT one = 1, two = 2, quot;

   quot = one / two;

   if(quot == 0.5) is_floatT = true;
   else is_floatT = false;

   return 0;

}//test_floatT()

template <class typeT, class floatT> int randomT<typeT, floatT>::mt_init_genrand(RANDOMT_WORD seed)
{
   init_genrand( (MT_TYPE) seed);

   return 0;

}//int mt_init_genrand(RANDOMT_WORD)

template <class typeT, class floatT> int randomT<typeT, floatT>::mt_init_by_array(MT_TYPE * seed_array, int len)
{
   init_by_array(seed_array, len);

   return 0;

}//int mt_init_by_array(MT_TYPE *, int)

template <class typeT, class floatT> int randomT<typeT, floatT>::mt_genrand(RANDOMT_WORD * mtg)
{
   if(!mtg) return -1;

   *mtg = (RANDOMT_WORD) genrand_int(); //genrand returns unsigned long, but we are
                     //assured that we have 32 bit RANDOMT_WORD

   return 0;
}//int mt_genrand(RANDOMT_WORD *)

//include appropriate Mersenne Twister code after diagnostics
#if MX_WORD_SIZE == 64
   #include "./bits/mt19937_64_mx64"
#else
   #include "./bits/mt19937ar_mx32"
#endif

template <class typeT, class floatT> int randomT<typeT, floatT>::set_seed(RANDOMT_WORD sd, typeT * nv)
{
   int retval = 0;
   if(sd == 0) 
   {
      seed = 1;  //Prevent an error (some generators can handle 0, some can't.)
      retval = 1; //report that this was changed
   }
   else seed = sd;

   switch(generator) //Do any generator specific seeding.
   {
      case MERSENNE_TWISTER:
         mt_init_genrand(seed);
         break;
      default: //For lcg's etc., this is easy.
         last_random = seed;  //last_random is actually used by the generators.
   }

   if(nv) next_value(nv); //set nv to the next value from the distribution.

   return retval;

}//int set_seed(RANDOMT_WORD, typeT *)

template <class typeT, class floatT> int randomT<typeT, floatT>::get_seed(RANDOMT_WORD * sd)
{
   *sd = seed;
   return 0;

}//int get_seed(RANDOMT_WORD *)

template <class typeT, class floatT> int randomT<typeT, floatT>::set_generator(unsigned int gen)
{
   if(mt) 
   {
      delete[] mt;
      mt = 0;
   }

   generator = gen;

   //Now set max_random based on the generator.
   switch(generator)
   {
      case ISO_PORTABLE:
         max_random = 32767; //From the ISO C example (this sucks by the way)
         break;
      case ISO_PORTABLE_ULONG:  //The ISO C constants, adapted to use 31 bits.
         max_random = 2147483647;
         break;
      case MIN_STD:
         max_random = 2147483647;
         break;
      case PARK_AND_MILLER1:
         max_random = 2147483647;
         break;
      case PARK_AND_MILLER2:
         max_random = 2147483647;
         break;
      case MERSENNE_TWISTER:
         mt = new MT_TYPE[MT_N];
         mti = MT_N + 1;
         max_random = RANDOMT_WORDMAX - 1; //2^32-2 since 2^32 can't be represented 
                                           //on a 32 bit machine.
                                           //This matters in division by (max_random + 1).
         break;
      default:

         #ifdef RANDOMT_USE_MXLIB
            error_report(MX_ERR_INVALARG, 
                        "Invalid generator. Setting default (MERSENNE_TWISTER).");
         #else
            std::cerr << "randomT error. Invalid generator: " << gen << "\n";
            std::cerr << "Setting default value: " << MERSENNE_TWISTER << " (MERSENNE_TWISTER)\n";
         #endif
         mt = new MT_TYPE[MT_N];
         mti = MT_N + 1;
         generator = MERSENNE_TWISTER; //default
         max_random = RANDOMT_WORDMAX - 1;
         return 1; //must have been an unrecognized generator.
   }

   return 0; //success.

}//int set_generator(unsigned int)

template <class typeT, class floatT> int randomT<typeT, floatT>::get_generator(unsigned int * gen) 
{
   *gen = generator;

   return 0;

}//int get_generator(unsigned int *gen)

template <class typeT, class floatT> int randomT<typeT, floatT>::get_max_random(RANDOMT_WORD *mr)
{
   *mr = max_random;

   return 0;

}//int get_max_rando(RANDOMT_WORD *)

template <class typeT, class floatT> int randomT<typeT, floatT>::set_distribution(unsigned int dist)
{
   if(dist > DISTRIBUTION_MAX)
   {
      #ifdef RANDOMT_USE_MXLIB
         error_report(MX_ERR_INVALARG, "Invalid distribution specified.");
      #else
         std::cerr << "randomT: error, invalid distribution specified." << std::endl;
      #endif
   }

   distribution = dist;

   switch(distribution)//size params for requirements of distribution.
   {
      case BASIC:
         params.resize(0);
         return 0;

      case STD_UNIFORM_DEVIATE:
         if(is_floatT)
         {
            params.resize(0);
            return 0;
         }
         else
         {
            #ifdef RANDOMT_USE_MXLIB
               error_report(MX_ERR_INVALARG, "Floating point type required for standard uniform deviates.");
            #else
               std::cerr << "randomT: error, floating point type required for standard uniform deviates." << std::endl;
            #endif
            distribution = BASIC;
            params.resize(0);
            return -2;
         }

      case UNIFORM_DEVIATE:
         params.resize(2);
         params[0] = 0;
         params[1] = 1;
         return 0;

      case STD_NORMAL_DEVIATE:
         if(is_floatT)
         {
            params.resize(0);
            return 0;
         }
         else
         {
            #ifdef RANDOMT_USE_MXLIB
               error_report(MX_ERR_INVALARG, "Floating point type required for standard normal deviate.");
            #else
               std::cerr << "randomT: error, floating point type required for standard normal deviate." << std::endl;
            #endif
            distribution = BASIC;
            params.resize(0);
            return -2;
         }

      case NORMAL_DEVIATE:
         if(is_floatT)
         {
            params.resize(2);
            return 0;
         }
         else
         {
            #ifdef RANDOMT_USE_MXLIB
               error_report(MX_ERR_INVALARG, "Floating point type required for normal deviate.");
            #else
               std::cerr << "randomT: error, floating point type required for normal deviate." << std::endl;
            #endif
            distribution = BASIC;
            params.resize(0);
            return -2;
         }

      case NORMAL_DEVIATE_SQREJECT:
         if(is_floatT)
         {
            params.resize(4);
            return 0;
         }
         else
         {
            #ifdef RANDOMT_USE_MXLIB
               error_report(MX_ERR_INVALARG, "Floating point type required for normal deviate.");
            #else
               std::cerr << "randomT: error, floating point type required for normal deviate." << std::endl;
            #endif
            distribution = BASIC;
            params.resize(0);
            return -2;
         }

      case DEXP_DEVIATE:
         if(is_floatT)
         {
            params.resize(2);
            return 0;
         }
         else
         {
            #ifdef RANDOMT_USE_MXLIB
               error_report(MX_ERR_INVALARG, "Floating point type required for normal deviate.");
            #else
               std::cerr << "randomT: error, floating point type required for normal deviate." << std::endl;
            #endif
            distribution = BASIC;
            params.resize(0);
            return -2;
         }

      default:         //failure, sets to BASIC and returns -1.
         distribution = BASIC;
         params.resize(0);
         return -1;
   }

   return -3; //not possible

}//int set_distribution(unsigned int)

template <class typeT, class floatT> int randomT<typeT, floatT>::get_distribution(unsigned int * dist)
{
   *dist = distribution;
   return 0;

}//int get_distribution(unsigned int *)

template <class typeT, class floatT> int randomT<typeT, floatT>::set_params(std::vector<typeT> *newP)
{
   params = *newP;

   return 0;

}//int set_params(std::vector<typeT, floatT> *newP)

template <class typeT, class floatT> int randomT<typeT, floatT>::get_params(std::vector<typeT> *ps)
{
   *ps = params;

   return 0;

}//int get_params(std::vector<typeT, floatT> *)

template <class typeT, class floatT> int randomT<typeT, floatT>::next_random(RANDOMT_WORD *nr)
{
   RANDOMT_SIGNED lv;

   switch(generator) //Pick the generator. Use a switch tree to be as fast as possible.
    {
      case ISO_PORTABLE: //From the ISO example.
         last_random = ((last_random * 1103515245 + 12345)/65536)% 32768;
         break;

      case ISO_PORTABLE_ULONG: //The ISO example, adapted for unsigned long quantities..
         last_random = (last_random * 1103515245 + 12345)% ((unsigned long) 2147483647 + 1);
         break;

      case MIN_STD: //See numerical recipes
         lv = last_random;
         lv = 16807 * (lv - (lv / 127773) * 127773) - (last_random / 127773) * 2836;
         if(lv < 0) last_random = (RANDOMT_WORD)(lv + 2147483647);
         else last_random = lv;
         break;

      case PARK_AND_MILLER1: //see numerical recipes
         lv = last_random;
         lv = 48271 * (lv - (last_random / 44488) * 44488) - (last_random / 44488) * 3399;
         if(lv < 0) last_random = (RANDOMT_WORD) (lv + 2147483647);
         else last_random = (RANDOMT_WORD) lv;
         break;

      case PARK_AND_MILLER2: //see numerical recipes
         lv = last_random;
         lv = 69621 * (lv - (last_random / 30845) * 30845) - (last_random / 30845) * 23902;
         if(lv < 0) last_random = (RANDOMT_WORD) (lv + 2147483647);
         else last_random = (RANDOMT_WORD) lv;
         break;

      case MERSENNE_TWISTER:
         mt_genrand(&last_random);
         break;

      default:
         return -1;

    }//switch

   *nr = last_random;

   return 0;

}//int next_random(RANDOMT_WORD *)

template <class typeT, class floatT> int randomT<typeT, floatT>::get_last_random(RANDOMT_WORD * lr)
{
   *lr = last_random;

   return 0;

}//int get_last_random(RANDOMT_WORD *)

template <class typeT, class floatT> int randomT<typeT, floatT>::get_std_uniform_deviate(typeT *sud)
{
   RANDOMT_WORD rw;

   next_random(&rw);

   *sud = (typeT) rw /  ((typeT) max_random + (typeT) 1);

   return 0;

}//int get_std_uniform(typeT *)

template <class typeT, class floatT> int randomT<typeT, floatT>::get_std_normal_deviate(typeT *snd)
{
   static bool good_dev = false; //leave these here instead of as class member so it
   static typeT saved_dev;       //only exists if this function is instantiated
   typeT dev1, dev2, unit_r, root;

   if(good_dev)
   {
      good_dev = false;
      *snd = saved_dev;
      return 0;
   }
   unit_r = 0;

   while(unit_r == 0 || unit_r > 1)
   {
      get_std_uniform_deviate(&dev1);
      get_std_uniform_deviate(&dev2);

      dev1 = 1 - 2 * dev1;
      dev2 = 1 - 2 * dev2;

      unit_r = dev1*dev1 + dev2*dev2;
   }

   root = -2* ((typeT) log(unit_r)) / unit_r;
   root = (typeT) sqrt(root);

   *snd = dev1*root;
   saved_dev = dev2*root;
   good_dev = true;

   return 0;

} //int get_std_normal_deviate(typeT *)

template <class typeT, class floatT> int randomT<typeT, floatT>::get_normal_deviate(typeT *nd)
{
   if(get_std_normal_deviate(nd) < 0) return -2;

   *nd = params[0] + params[1] * (*nd);

   return 0;

} //int get_normal_deviate(typeT *)

template <class typeT, class floatT> int randomT<typeT, floatT>::get_normal_deviate_sqreject(typeT *nd)
{
   RANDOMT_WORD rw;
   //Tested and verified to produce a normal distribution 1/15/05.
   pass = 0;
   if(params[3] == 0)
   {
      *nd = params[2];
      return 0;
   }
   while(!pass)
   {
      next_random(&rw);
      rand1 = (typeT) ((typeT) rw/((typeT) max_random+(typeT)1))*(params[1]-params[0]) + params[0];
      next_random(&rw);
      rand2 = (typeT) ((typeT) rw/((typeT) max_random+(typeT)1))*((typeT) 0.398942280401/params[3]);
      if(rand2 <= exp(-.5*((rand1 - params[2]) * (rand1-params[2])) / (params[3]*params[3])) / (params[3]*2.50662827463)) pass = 1; //(sqrt(2pi)

   }

   *nd = rand1;

   return 0;
}//int get_normal_deviate_sqreject(typeT *)

template <class typeT, class floatT> int randomT<typeT, floatT>::get_dexp_deviate(typeT *nd)
{
   RANDOMT_WORD rw;
   int sgnx = 1;

   next_random(&rw);

   *nd = 0.5 - ( ((typeT) rw) / ((typeT) max_random) );

   if(*nd < 0) 
   {
      sgnx = -1;
      *nd *= -1;
   }

   *nd = params[0] - params[1] * sgnx*log(1-2*(*nd));

   return 0;
}

template <class typeT, class floatT> int randomT<typeT, floatT>::next_value(typeT * nv)
{
   int retval;
   RANDOMT_WORD rw;

   switch(distribution)
   {
      case BASIC:
         retval = next_random(&rw);
         *nv = (typeT) rw;
         return retval;

      case STD_UNIFORM_DEVIATE:
         return get_std_uniform_deviate(nv);

      case UNIFORM_DEVIATE:
         retval = get_std_uniform_deviate(nv);
         *nv =  ( (*nv) * (params[1] - params[0])) + params[0];
         return retval;

      case STD_NORMAL_DEVIATE:
         return get_std_normal_deviate(nv);

      case NORMAL_DEVIATE:
         return get_normal_deviate(nv);

      case NORMAL_DEVIATE_SQREJECT:
         return get_normal_deviate_sqreject(nv);

      case DEXP_DEVIATE:
         return get_dexp_deviate(nv);

      default:
         next_random(&rw);
         *nv = (typeT) rw;
         return 1;
      }

   return -2; //not possible

}//int next_value(typeT *)

//Assignment
template <class typeT, class floatT> int randomT<typeT, floatT>::assign(randomT<typeT, floatT> r)
{
   //Create an exact copy, including last_random.  Result is two synchronized generators.
   r.get_generator(&generator);

   if(generator == MERSENNE_TWISTER)
   {
      MT_TYPE *nmt;
      r.get_mt(&nmt);
      for(int i =0; i < MT_N; i++) mt[i] = nmt[i];
      r.get_mti(&mti);
   }

   r.get_distribution(&distribution);
   r.get_max_random(&max_random);

   r.get_seed(&seed); //always save it so we know where we started.

   r.get_last_random(&last_random); //this synchronizes.

   r.get_params(&params);

   return 0;

}//assign(randomT<typeT, floatT>)

template <class typeT, class floatT> randomT<typeT, floatT> randomT<typeT, floatT>::operator =(randomT<typeT, floatT> R)
{
   assign(R);
   return (*this);
}//operator =(randomT<typeT, floatT>)

template <class typeT, class floatT> typeT randomT<typeT, floatT>::operator =(RANDOMT_WORD sd)
{
   typeT nv;
   set_seed(sd, &nv);
   return nv;
}//operator =(RANDOMT_WORD sd)

//reference
template <class typeT, class floatT> randomT<typeT, floatT>::operator typeT() 
{
   typeT nv;
   next_value(&nv);
   return nv;
}//operator typeT()

} //namespace MX

#endif //__randomT__

/*5/22/06: added 64 bit mersenne twister support
*/
